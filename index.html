<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<title>Image Maker Studio</title>
<link rel="icon" type="image/png" href="favicon.ico">
<!-- === FONT LOADING OPTIMIZATION: Load critical and fallback fonts first === -->
<link href="https://fonts.googleapis.com/css2?family=VT323&family=Roboto:wght@400;700&display=swap" rel="stylesheet">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
<style>
/* --- CRITICAL CSS: Inlined for fastest first paint --- */
:root{--bg:#f2efe8;--ink:#2b2b2b;--mid:#c2c2c2;--light:#faf9f5;--light-rgb:250,249,245;--shadow:#7a7a7a;--danger-color:#cc4444;--action-color:#4477cc;--success-color:#55cc55;--bg-rgb:242,239,232;--action-color-rgb:68,119,204;transition:--bg .3s, --ink .3s, --mid .3s, --light .3s, --shadow .3s, --action-color .3s, --danger-color .3s, --success-color .3s}
html{box-sizing:border-box}*,:before,:after{box-sizing:inherit}
body{font-family:'VT323',monospace;background:var(--bg);color:var(--ink);display:flex;flex-direction:column;align-items:center;padding:10px;margin:0;height:100vh;overflow:hidden;transition:background-color .3s,color .3s}
#loading-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background-color:#faf9f5;color:#2b2b2b;display:flex;align-items:center;justify-content:center;z-index:9999;transition:opacity .5s ease-in-out}
#loading-overlay h1{font-family:'VT323',monospace;font-size:2.5rem;text-shadow:1px 1px 0 #000}
#loading-overlay h1::after{content:'.';display:inline-block;width:3ch;text-align:left;animation:ellipsis 1.4s infinite}
@keyframes ellipsis{0%{content:'.'}33%{content:'..'}66%{content:'...'}}

/* === INTEGRATED DROPDOWN STYLES START === */
.window{position:relative;background:var(--light);border:2px solid var(--ink);box-shadow:2px 2px 0 var(--shadow);width:100%;max-width:1600px;margin:0 auto;height:calc(100vh - 20px);display:flex;flex-direction:column;overflow:hidden;transition:background-color .3s,border-color .3s,box-shadow .3s;border-radius:3px}
.titlebar{height:28px;background:var(--mid);display:flex;align-items:center;justify-content:space-between;padding:0 8px;border-bottom:2px solid var(--ink);font-size:20px;flex-shrink:0;cursor:default;position:relative;transition:background-color .3s,border-color .3s}
.titlebar-controls{display:flex;align-items:center;gap:8px}
.controls-fake{display:flex;gap:4px}.btn-square{width:16px;height:16px;background:var(--light);border:2px solid var(--ink)}
.controls-fake .btn-square:first-child{background-color:var(--success-color)}
.controls-fake .btn-square:last-child{background-color:var(--danger-color)}

/* Dropdown Button Styling */
#erase-tool-btn, #shortcuts-btn, #text-btn, #toggle-view-btn, #visuals-btn, #ai-tools-btn {
    font-family: inherit;
    font-size: 1.1rem;
    background: var(--light);
    border: 2px solid var(--ink);
    padding: 0 8px;
    cursor: pointer;
    color: var(--ink);
    border-radius: 3px;
    box-shadow: 2px 2px 0 var(--shadow);
    transition: transform .15s ease-out, box-shadow .15s ease-out;
}
#erase-tool-btn:hover, #shortcuts-btn:hover, #text-btn:hover, #toggle-view-btn:hover, #visuals-btn:hover, #ai-tools-btn:hover {
    transform: translate(1px, 1px);
    box-shadow: 1px 1px 0 var(--shadow);
}
#erase-tool-btn:active, #shortcuts-btn:active, #text-btn:active, #toggle-view-btn:active, #visuals-btn:active, #ai-tools-btn:active {
    transform: translate(2px, 2px);
    box-shadow: none;
}
#toggle-view-btn { /* Specific style for the toggle button */
    padding: 0 4px;
    font-size: 18px;
}

/* Dropdown Panel Styling */
#erase-tool-dropdown, #shortcuts-dropdown, #text-dropdown, #visuals-dropdown, #ai-tools-dropdown {
    position: absolute;
    top: 28px;
    background: rgba(var(--light-rgb), .65);
    -webkit-backdrop-filter: blur(4px);
    backdrop-filter: blur(4px);
    border: 2px solid var(--ink);
    box-shadow: 2px 2px 0 var(--shadow);
    padding: .5rem 1rem;
    z-index: 100;
    width: 250px;
    border-radius: 4px;
    opacity: 0;
    transform: translateY(-10px);
    transition: opacity .2s ease-out, transform .2s ease-out;
    pointer-events: none;
    display: none;
}

/* Positioning for each dropdown */
#visuals-dropdown   { right: 382px; width: 280px; }
#erase-tool-dropdown  { right: 288px; }
#ai-tools-dropdown    { right: 198px; }
#text-dropdown        { right: 102px; width: 280px; }
#shortcuts-dropdown   { right: 8px; }


/* Visibility Toggle */
#erase-tool-dropdown.visible, #shortcuts-dropdown.visible, #text-dropdown.visible, #visuals-dropdown.visible, #ai-tools-dropdown.visible {
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
    display: block; /* Use display to show/hide */
}

/* Headers and content within dropdowns */
#erase-tool-dropdown h5, #shortcuts-dropdown h5, #text-dropdown h5, #visuals-dropdown h5, #ai-tools-dropdown h5 {
    margin: 0 0 .5rem;
    font-size: 1.25rem;
    text-align: center;
}
#erase-tool-dropdown h6, #text-dropdown h6, #visuals-dropdown h6 {
    font-size: 1.15rem;
    font-weight: 700;
    text-align: left;
    margin-top: .5rem;
    margin-bottom: .5rem;
    border-bottom: 2px solid var(--mid);
    padding-bottom: 2px;
}

#shortcuts-dropdown ul{margin:0;padding:0;list-style:none;font-size:1rem}
#shortcuts-dropdown li{display:flex;justify-content:space-between;padding:2px 0}
#shortcuts-dropdown li kbd{font-family:inherit;border:2px solid var(--ink);padding:0 4px;background:var(--bg);transition:background-color .3s,border-color .3s,color .3s}

/* Additional styles to integrate with your existing code */
main#studio-container { display:grid; grid-template-columns:320px 1fr; grid-template-rows:minmax(0,1fr); gap:1.5rem; padding:1.5rem; flex-grow:1; min-height:0 }
#controls-panel { display:flex; flex-direction:column; gap:1rem; overflow-y:auto; min-height:0 }
#canvas-panel { display:flex; align-items:center; justify-content:center; border:2px solid var(--ink); background-color:var(--mid); position:relative; min-height:0; transition:background-color .5s ease-in-out; overflow:hidden }
#controls-panel fieldset { border: 2px solid var(--ink); padding: .8rem; margin: 0; }
.hidden { display: none !important; }
.disabled { opacity: 0.5; pointer-events: none; }
.slider-container { margin-bottom: 0.5rem; }
.mg-btn{font-family:inherit;font-size:18px;background:var(--light);border:2px solid var(--ink);padding:8px 16px;margin:4px;cursor:pointer;text-decoration:none;color:var(--ink);transition:.2s all;box-shadow:2px 2px 0 var(--shadow);width:100%;white-space:nowrap;border-radius:3px}
.mg-btn:hover{transform:translate(1px,1px);box-shadow:1px 1px 0 var(--shadow)}
.mg-btn:active{transform:translate(2px,2px);box-shadow:none}.mg-btn.disabled,.mg-btn:disabled{opacity:.5;pointer-events:none;box-shadow:none;transform:none}
.mg-btn.active{background-color:var(--action-color);color:var(--light);box-shadow:none;transform:translate(2px,2px)}
.eraser-mode-selector { display: flex; gap: 0.5rem; }
#text-layer-manager { display: flex; gap: .5rem; align-items:center; padding-bottom:.5rem; margin-bottom:.5rem; border-bottom:2px solid var(--mid); }
.effects-checkbox{display:flex;align-items:center;margin-top:.5rem}
.effects-controls{padding-left:1.5rem;border-left:2px solid var(--mid);margin-left:.5rem}
footer{height:28px;padding:0 8px;display:flex;justify-content:space-between;align-items:center;font-size:.9rem;flex-shrink:0;gap:1rem;background-color:var(--light);color:var(--ink);transition:background-color .3s,color .3s;border-top:2px solid var(--ink)}
.footer-links,.footer-right{display:flex;flex-wrap:wrap;gap:1.5rem;align-items:center}
footer a{color:var(--ink);text-decoration:none;transition:opacity .2s,color .3s;opacity:.7}
footer a:hover{opacity:1}footer a i{margin-right:.5em}
.mg-overlay-base{position:fixed;top:0;left:0;width:100%;height:100%;z-index:1000;display:none;align-items:center;justify-content:center;opacity:1;pointer-events:auto;}
#canvas-placeholder { width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; }
.placeholder-text { color: var(--shadow); }

/* AI Model Selector Styles */
#ai-model-select {
  position: relative;
}
#ai-model-trigger {
  background: var(--bg);
  border: 1px solid var(--ink);
  padding: 4px 8px;
  font-size: 1rem;
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: background-color .3s, border-color .3s;
}
#ai-model-trigger:focus, #ai-model-select.open #ai-model-trigger {
  border-color: var(--action-color);
}
#ai-model-trigger span {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
#ai-model-trigger i {
  transition: transform .2s ease-in-out;
  font-size: .8em;
  margin-left: 0.5rem;
}
#ai-model-select.open #ai-model-trigger i {
  transform: rotate(180deg);
}
#ai-model-dropdown {
  position: absolute;
  top: calc(100% + 2px);
  left: 0;
  right: 0;
  background: var(--light);
  border: 1px solid var(--ink);
  z-index: 101;
  box-shadow: 2px 2px 0 var(--shadow);
}
#ai-model-list {
  list-style: none;
  margin: 0;
  padding: 0;
}
#ai-model-list li {
  padding: 6px 10px;
  cursor: pointer;
  transition: background-color .2s;
  white-space: nowrap;
  font-size: .9rem;
}
#ai-model-list li:hover {
  background-color: var(--mid);
}
#ai-model-list li.selected {
  background-color: var(--action-color);
  color: var(--light);
}
.compact-color-row {
    display: flex;
    justify-content: space-between;
    gap: 1rem;
}
.compact-color-row .slider-container {
    flex-grow: 1;
}

/* === INTEGRATED DROPDOWN STYLES END === */
</style>
</head>
<body>
<!-- === SVG FILTERS (remain in body) === -->
<svg width="0" height="0" style="position:absolute;pointer-events:none;">
    <defs>
        <filter id="filter-crayon-classic"><feTurbulence type="fractalNoise" baseFrequency="0.1" numOctaves="1" seed="5" result="warp" /><feDisplacementMap xChannelSelector="R" yChannelSelector="G" scale="10" in="SourceGraphic" in2="warp" /></filter>
        <filter id="filter-vine"><feTurbulence type="fractalNoise" baseFrequency="0.02 0.1" numOctaves="1" result="warp" seed="2"/><feDisplacementMap xChannelSelector="R" yChannelSelector="G" scale="10" in="SourceGraphic" in2="warp" /></filter>
        <filter id="filter-wiggle"><feTurbulence type="fractalNoise" baseFrequency="0.04" numOctaves="1" result="warp" /><feDisplacementMap xChannelSelector="R" yChannelSelector="G" scale="4" in="SourceGraphic" in2="warp" /></filter>
        <filter id="filter-torn-paper"><feTurbulence type="fractalNoise" baseFrequency="0.02 0.09" numOctaves="1" result="turbulence"/><feDisplacementMap in="SourceGraphic" in2="turbulence" scale="8" xChannelSelector="R" yChannelSelector="G" result="displaced"/><feColorMatrix in="displaced" type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 999 -450" /></filter>
    </defs>
</svg>

<div class=window>
<div id="loading-overlay"><h1>Initializing Image-Maker-Studio.exe</h1></div>
<div class=titlebar><span>Image-Maker-Studio.exe</span><div class=titlebar-controls>
    <button id="toggle-view-btn" title="Toggle Canvas View (Z)">⬚</button>
    <button id=visuals-btn>Edit Visuals</button>
    <div id="visuals-dropdown">
        <h5>Visuals Editor</h5>
        <div id="visuals-tabs" class="eraser-mode-selector" style="margin-bottom: 0.8rem;"><button id="visuals-tab-asset" class="mg-btn" type="button">Asset</button><button id="visuals-tab-background" class="mg-btn active" type="button">Background</button></div>
        <div id="asset-tab-panel" class="hidden">
            <div id="asset-visuals-controls" class="disabled">
                <h6>Filters</h6>
                <div class=slider-container><label for=asset-opacity>Opacity</label><input type=range id=asset-opacity min=0 max=1 step=.01 value=1></div>
                <div class=slider-container><label for=asset-brightness>Brightness</label><input type=range id=asset-brightness min=0 max=2 step=.01 value=1></div>
                <div class=slider-container><label for=asset-saturation>Saturation</label><input type=range id=asset-saturation min=0 max=2 step=.01 value=1></div>
                <h6>Drop Shadow</h6>
                <div class="effects-checkbox"><input type="checkbox" id="shadow-enable"><label for="shadow-enable">Enable</label></div>
                <div id="shadow-controls" class="effects-controls disabled"><div class="slider-container"><label for="shadow-color">Color</label><input type="color" id="shadow-color" value="#000000"></div><div class="slider-container"><label for="shadow-blur">Blur</label><input type="range" id="shadow-blur" min="0" max="50" value="10"></div><div class="slider-container"><label for="shadow-offset-x">Offset X</label><input type="range" id="shadow-offset-x" min="-50" max="50" value="10"></div><div class="slider-container"><label for="shadow-offset-y">Offset Y</label><input type="range" id="shadow-offset-y" min="-50" max="50" value="10"></div></div>
                <h6>Edge</h6>
                <div class="effects-checkbox"><input type="checkbox" id="asset-edge-enable"><label for="asset-edge-enable">Enable</label></div>
                <div id="asset-edge-controls" class="effects-controls disabled"><div class="slider-container"><label for="asset-edge-color">Color</label><input type="color" id="asset-edge-color" value="#FFFFFF"></div><div class="slider-container"><label for="asset-edge-width">Width</label><input type="range" id="asset-edge-width" min="0" max="20" value="4"></div></div>
            </div>
        </div>
        <div id="background-tab-panel">
             <div id="background-visuals-controls">
                <h6>Background Filters</h6>
                <div class=slider-container><label for=bg-brightness>Brightness</label><input type=range id=bg-brightness min=0 max=2 step=.01 value=1></div>
                <div class=slider-container><label for=bg-saturation>Saturation</label><input type=range id=bg-saturation min=0 max=2 step=.01 value=1></div>
            </div>
        </div>
    </div>
    <button id="erase-tool-btn">Erase</button><div id="erase-tool-dropdown"><h5>Eraser Tool</h5><div class=eraser-mode-selector><button class="mg-btn" id=erase-btn>Erase</button><button class="mg-btn" id=unerase-btn>Unerase</button></div><div id="eraser-controls-wrapper" class="disabled"><h6>Brush Settings</h6><div class="slider-container"><label for="eraser-size">Brush Size</label><input type="range" id="eraser-size" min="5" max="200" value="40"></div><div class="slider-container"><label for="eraser-opacity">Strength</label><input type="range" id="eraser-opacity" min="0" max="1" step=".01" value="1"></div><h6>History</h6><button class="mg-btn" id="undo-erase-btn" disabled>Undo</button><button class="mg-btn" id="revert-erasing-btn">Reset Layer</button></div></div><button id="ai-tools-btn">AI Tools</button><div id="ai-tools-dropdown"><h5>AI Tools</h5></div><button id=text-btn>Text</button><div id=text-dropdown><h5>Text Editor</h5><div id=text-layer-manager><div id=text-layer-palette></div><button id=add-new-text-layer-btn class="palette-slot empty" title="Add new text layer">+</button></div><div id=text-visuals-controls class=disabled><div class=slider-container><label for=text-content>Text Content</label><textarea id=text-content rows=3 style=width:100%;font-family:inherit;font-size:1rem;padding:4px;border:1px solid var(--ink);background:var(--bg)>New Text</textarea></div>
        <div class="slider-container">
            <label>Font</label>
            <div id="custom-font-select">
                <div id="font-select-trigger" tabindex="0"><span>VT323</span> <i class="fas fa-chevron-down"></i></div>
                <div id="font-select-dropdown" class="hidden"><ul id="font-select-list"></ul></div>
            </div>
        </div>
        <div class=slider-container><label for=text-size>Size</label><input type=range id=text-size min=20 max=800 step=1 value=410></div>
        <div class="compact-color-row">
            <div class=slider-container><label for=text-color>Color</label><input type=color id=text-color value=#FFFFFF style=width:100%;border:none;padding:0></div>
            <div class=slider-container><label for="text-edge-color">Edge Color</label><input type="color" id="text-edge-color" value="#000000" style="width:100%;border:none;padding:0"></div>
        </div>
        <div class="slider-container"><label for="text-edge-width">Edge Density</label><input type="range" id="text-edge-width" min="0" max="20" step="1" value="0"></div>
        <h6>Drop Shadow</h6>
        <div class="effects-checkbox" style="display: flex; justify-content: space-between; align-items: center;">
            <div><input type="checkbox" id="text-shadow-enable"><label for="text-shadow-enable">Enable</label></div>
            <div class="slider-container" style="margin-bottom: 0; width: 60%;"><label for="text-shadow-color" style="margin-top:0;">Color</label><input type="color" id="text-shadow-color" value="#000000" style="width:100%;border:none;padding:0"></div>
        </div>
        <div id="text-shadow-controls" class="effects-controls disabled">
            <div class="slider-container"><label for="text-shadow-blur">Blur</label><input type="range" id="text-shadow-blur" min="0" max="50" value="10"></div>
            <div class="slider-container"><label for="text-shadow-offset-x">Offset X</label><input type="range" id="text-shadow-offset-x" min="-50" max="50" value="10"></div>
            <div class="slider-container"><label for="text-shadow-offset-y">Offset Y</label><input type="range" id="text-shadow-offset-y" min="-50" max="50" value="10"></div>
        </div>
        <div id="text-zorder-controls" style="display:flex;gap:.5rem;align-items:center;margin-top:.5rem;"><button id="text-move-back" class="mg-btn" type="button" style="width:auto;padding:2px 8px;">Move back</button><button id="text-move-forward" class="mg-btn" type="button" style="width:auto;padding:2px 8px;">Move forward</button></div></div></div>
<button id=shortcuts-btn>Shortcuts</button><div class=controls-fake><div class=btn-square></div><div class=btn-square></div></div><div id=shortcuts-dropdown><h5>Keyboard Shortcuts</h5><ul><li><span>Toggle Canvas View</span><kbd>Z</kbd></li><li><span>Enlarge Asset</span><kbd>D</kbd></li><li><span>Shrink Asset</span><kbd>F</kbd></li><li><span>Flip Asset Horizontally</span><kbd>S</kbd></li><li><span>Move Layer Forward</span><kbd>Q</kbd></li><li><span>Move Layer Backward</span><kbd>W</kbd></li><li><span>Delete Asset</span><kbd>Delete</kbd></li></ul></div></div></div><main id=studio-container><div id=controls-panel><fieldset id="assets-folder-fieldset"><legend>Assets Folder</legend><div id="assets-folder-actions"><p>Your saved assets</p><button id="mg-view-all-local-assets-btn" class="mg-btn" style="width:auto; padding: 2px 8px; font-size: 16px; margin: 0;">View All</button></div><div id="mg-local-asset-palette"></div></fieldset><fieldset id="layers-fieldset"><legend>Layers</legend><p id=layer-instructions class=placeholder-text>Add a background to begin.</p><div id="mg-asset-palette"></div></fieldset>
<fieldset><legend>Canvas Actions</legend><button class="mg-btn generate" id=mg-download-image-btn disabled>Download Image</button><div class="action-buttons" style="margin-top: 0.5rem;"><button class="mg-btn" id="mg-clear-canvas-btn" disabled>Clear Canvas</button></div></fieldset></div><div id=canvas-panel>
<div id="mg-selection-box"></div>
<canvas id=mg-movie-canvas></canvas><canvas id=mg-controls-overlay-canvas></canvas><canvas id="mg-pasteboard-overlay-canvas"></canvas><canvas id="mg-eraser-zoom"></canvas>
<div id="mg-eraser-hud">
    <div class="row eraser-mode-selector" style="margin-bottom:6px; width: 100%;"><button class="mg-btn" id="mg-hud-erase-btn" type="button" title="Erase">Erase</button><button class="mg-btn" id="mg-hud-unerase-btn" type="button" title="Unerase">Unerase</button></div>
    <div class="row"><label for="mg-eraser-size-mini" style="font-size:14px;">Size</label><input id="mg-eraser-size-mini" type="range" min="5" max="200" value="40"></div>
    <div class="row" style="margin-top: 4px;"><label for="mg-eraser-strength-mini" style="font-size:14px;">Strength</label><input id="mg-eraser-strength-mini" type="range" min="0" max="1" step="0.01" value="1"></div>
</div>
<div id=canvas-placeholder><img src="welcome.png" alt="Click or drag and drop to start creating"><h3>Click, Paste, or Drag & Drop File</h3><p>to add a background image & begin creating</p></div></div></main>
<footer>
    <div class="footer-links"><a href="#"><i class="fas fa-envelope"></i>feedback</a><a href="#"><i class="fab fa-twitter"></i>updates</a><a href="#"><i class="fas fa-file-alt"></i>license</a><a href="#"><i class="fas fa-shield-alt"></i>report</a><a href="#"><i class="fas fa-lock"></i>privacy</a></div>
    <div class="footer-right"><a href="#" id="border-style-link"><i class="fas fa-border-style"></i><span id="current-border-style-name"></span></a><a href="#" id="theme-select-link"><i class="fas fa-palette"></i><span id="current-theme-name"></span></a><a href="#" id="version-link"><i class="fas fa-code-branch"></i>v4.18.1</a></div>
</footer>
<input type=file id=initial-background-input accept=image/* style=display:none></div>
<div id=mg-asset-library-overlay class=mg-overlay-base><div id=mg-asset-picker-grid-wrapper class=window><button id=mg-asset-library-close class=overlay-close-btn>X</button><h4>Click an asset to add it to the canvas</h4><div id=mg-asset-picker-grid></div><div id=mg-asset-picker-actions><label class=mg-btn>Upload Custom <input type=file id=mg-asset-picker-file accept=image/* style=display:none></label></div></div></div>
<div id=mg-local-asset-folder-overlay class=mg-overlay-base><div id=mg-local-asset-folder-wrapper class=window><button id=mg-local-asset-folder-close class=overlay-close-btn>X</button><h4>Your Library</h4><div id="mg-local-asset-tabs" style="display:flex;gap:.5rem;justify-content:center;margin-bottom:.5rem;"><button id="tab-assets" class="mg-btn tab" type="button">Assets</button><button id="tab-backgrounds" class="mg-btn tab" type="button">Backgrounds</button></div><div id="mg-local-asset-grid-assets"></div><div id="mg-local-asset-grid-backgrounds" class="hidden"></div></div></div>
<div id=mg-confirmation-overlay class=mg-overlay-base><div id=mg-confirmation-dialog class=window><p id=mg-confirmation-text>Are you sure?</p><div class=action-buttons><button id="mg-confirm-yes-btn" class="mg-btn active" type="button">Yes</button><button id="mg-confirm-no-btn" class="mg-btn" type="button">No</button></div></div></div>
<div id="mg-asset-action-overlay" class=mg-overlay-base style="display: none;"><div id="mg-asset-action-dialog" class=window><p>How would you like to use this asset?</p><div class="action-buttons"><button id="mg-asset-action-background-btn" class="mg-btn">Set as Background</button><button id="mg-asset-action-layer-btn" class="mg-btn">Add as Layer</button></div></div></div>
<div id="version-popup-overlay" style="display: none;">
    <div id="version-popup-content">
        <span id="close-popup">X</span>
        <h4>v4.18.1</h4>
        <h6>12 Sep 2025</h6>
        <p>A performance and user experience patch focused on improving initial load times and refining UI elements based on user feedback.</p>
        <h5>Features</h5>
        <ul>
            <li><strong>performance:</strong> Implemented "critical CSS" to ensure the loading screen appears almost instantly. Non-essential styles are now loaded asynchronously.</li>
            <li><strong>performance:</strong> Decorative fonts are now loaded on-demand when the user opens the Text Editor for the first time, saving multiple network requests on initial load.</li>
        </ul>
        <h5>Improvements</h5>
        <ul>
            <li><strong>performance:</strong> Removed the background removal tool to significantly reduce the initial JavaScript bundle size.</li>
            <li><strong>performance:</strong> Replaced the welcome video with a static, compressed PNG to speed up the placeholder view.</li>
            <li><strong>ux:</strong> The border style selector popup is now a perfectly sized, non-scrollable grid with centered previews and improved spacing.</li>
            <li><strong>ux:</strong> Previews in the border style selector now use the theme's main ink color (e.g., black) instead of green for better visual consistency.</li>
            <li><strong>ui:</strong> Added small 'x' markers to the corners of the "Classic Barb" border preview to better reflect its on-canvas appearance.</li>
        </ul>
        <h5>Fixes</h5>
        <ul>
            <li><strong>style:</strong> Corrected the "Classic Wiggle" rotator handle on the canvas, which was incorrectly showing a black fill; it now correctly shows only the green stroke.</li>
        </ul>

        <hr style="margin: 2rem 0;">

        <h4>v4.18.0</h4>
        <h6>11 Sep 2025</h6>
        <p>A major update focused on UI/UX enhancements and bug fixes, particularly for the editing tools.</p>
        <h5>Features</h5>
        <ul>
            <li><strong>ui:</strong> re-architected the 'Edit Visuals' dropdown into a tabbed interface ("Asset" and "Background") to improve organization and ensure it fits on smaller screens</li>
            <li><strong>eraser:</strong> added a floating side HUD that appears when the eraser tool is active, providing quick access to primary controls without reopening the main dropdown</li>
            <li><strong>ux:</strong> implemented a smooth "scrubbing" effect for sliders, which fades out non-essential UI elements during adjustment for better focus</li>
        </ul>
        <h5>Improvements</h5>
        <ul>
            <li><strong>style:</strong> reduced border and box-shadow thickness sitewide for a lighter, more refined aesthetic</li>
            <li><strong>eraser:</strong> redesigned the side HUD with clear "Erase" and "Unerase" buttons that dynamically match the application's selected theme</li>
            <li><strong>eraser:</strong> added a "Strength" slider to the side HUD for quick access to both primary brush settings</li>
            <li><strong>eraser:</strong> refined the activation flow to keep the main dropdown open for initial adjustments; the side HUD now appears only after the user moves to the canvas</li>
            <li><strong>ui:</strong> added smooth fade-in and fade-out transitions to the eraser's side HUD and magnifying zoom window for a more polished feel</li>
            <li><strong>ux:</strong> the "Asset" tab in the Visuals Editor is now always clickable and provides a helpful toast message if no asset is currently selected</li>
            <li><strong>ux:</strong> improved instructional text for the eraser, changing "Armed" to "Activated" and clarifying how to deactivate the tool</li>
            <li><strong>text:</strong> renamed "Stroke Width" to "Density" in the Text Editor</li>
            <li><strong>performance:</strong> capped the eraser's undo history to a maximum of 10 steps per layer to prevent excessive memory usage</li>
        </ul>
        <h5>Fixes</h5>
        <ul>
            <li><strong>download:</strong> implemented a missing `toast` function that was causing a critical error and preventing the "Download Image" button from working</li>
            <li><strong>eraser:</strong> the floating side HUD no longer incorrectly disappears when a user interacts with its sliders</li>
            <li><strong>eraser:</strong> the Size and Strength sliders are now perfectly synced in real-time between the main dropdown and the side HUD</li>
            <li><strong>eraser:</strong> the side HUD now correctly disappears the moment an erase action begins (mouse-down) and reappears immediately upon release (mouse-up)</li>
            <li><strong>ui:</strong> disabled the "scrubbing" fade-out effect for all "Strength" sliders, as hiding the UI was not necessary for that specific adjustment</li>
        </ul>
    </div>
</div>
<div id="theme-popup-overlay" style="display: none;"><div id="theme-popup-content"><ul id="theme-list"></ul></div></div>
<div id="border-style-popup-overlay" style="display: none;"><div id="border-style-popup-content"><div class="border-style-grid"></div></div></div>
<div id=mg-toast></div>

<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/ort.min.js"></script>
<script>
    (function () {
        // --- ONNX RUNTIME CONFIG ---
        ort.env.wasm.simd = true;
        ort.env.wasm.numThreads = 1; // Use single-thread for max compatibility

        // --- DEFERRED ASSETS LOGIC ---
        let secondaryFontsLoaded = false;
        function loadSecondaryFonts() {
            if (secondaryFontsLoaded) return;
            const link = document.createElement('link');
            link.href = 'https://fonts.googleapis.com/css2?family=Anton&family=Indie+Flower&family=Londrina+Outline&family=Patua+One&family=Pixelify+Sans&family=Press+Start+2P&family=Rubik+Mono+One&family=Young+Serif&display=swap';
            link.rel = 'stylesheet';
            document.head.appendChild(link);
            secondaryFontsLoaded = true;
        }

        function injectNonCriticalStyles() {
            const nonCriticalCSS = `.window{position:relative;background:var(--light);border:1px solid var(--ink);box-shadow:2px 2px 0 var(--shadow);width:100%;max-width:1600px;margin:0 auto;height:calc(100vh - 20px);display:flex;flex-direction:column;overflow:hidden;transition:background-color .3s,border-color .3s,box-shadow .3s;border-radius:3px}.titlebar{height:28px;background:var(--mid);display:flex;align-items:center;justify-content:space-between;padding:0 8px;border-bottom:1px solid var(--ink);font-size:20px;flex-shrink:0;cursor:default;position:relative;transition:background-color .3s,border-color .3s}.titlebar-controls{display:flex;align-items:center;gap:8px}.controls-fake{display:flex;gap:4px}.btn-square{width:16px;height:16px;background:var(--light);border:1px solid var(--ink)}.controls-fake .btn-square:first-child{background-color:var(--success-color)}.controls-fake .btn-square:last-child{background-color:var(--danger-color)}#shortcuts-btn,#visuals-btn,#text-btn,#toggle-view-btn,#erase-tool-btn,#ai-tools-btn{font-family:inherit;font-size:1.1rem;background:var(--light);border:1px solid;border-color:var(--mid) var(--ink) var(--ink) var(--mid);padding:0 8px;cursor:pointer;transition:all .2s;color:var(--ink);border-radius:3px;transform:translateY(-1px)}#shortcuts-btn:hover,#visuals-btn:hover,#text-btn:hover,#toggle-view-btn:hover,#erase-tool-btn:hover,#ai-tools-btn:hover{transform:translateY(-2px);filter:brightness(1.1)}#shortcuts-btn:active,#visuals-btn:active,#text-btn:active,#toggle-view-btn:active,#erase-tool-btn:active,#ai-tools-btn:active,#erase-tool-btn.active{transform:translateY(0);border-color:var(--ink) var(--mid) var(--mid) var(--ink)}#toggle-view-btn{padding:0 4px;font-size:18px}#shortcuts-dropdown{right:8px}#shortcuts-dropdown.visible{display:block}#shortcuts-dropdown h5{margin:0 0 .5rem 0;font-size:1.25rem;text-align:center}#shortcuts-dropdown ul{margin:0;padding:0;list-style:none;font-size:1rem}#shortcuts-dropdown li{display:flex;justify-content:space-between;padding:2px 0}#shortcuts-dropdown li kbd{font-family:inherit;border:1px solid var(--ink);padding:0 4px;background:var(--bg)}#visuals-dropdown,#text-dropdown,#shortcuts-dropdown,#erase-tool-dropdown,#ai-tools-dropdown{display:none;position:absolute;top:28px;background:rgba(var(--light-rgb),.3);backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);border:1px solid var(--ink);box-shadow:2px 2px 0 var(--shadow);padding:.5rem 1rem;z-index:100;width:250px;transition:background .2s,backdrop-filter .2s,box-shadow .2s,border-color .2s;border-radius:4px}#visuals-dropdown{right:382px}#erase-tool-dropdown{right:288px}#ai-tools-dropdown{right:198px}#text-dropdown{right:74px}#visuals-dropdown.visible,#text-dropdown.visible,#erase-tool-dropdown.visible,#ai-tools-dropdown.visible{display:block}#visuals-dropdown h5,#visuals-dropdown h6,#visuals-dropdown .slider-container,#text-dropdown h5,#text-dropdown h6,#text-dropdown .slider-container,#erase-tool-dropdown h5,#erase-tool-dropdown h6,#erase-tool-dropdown .eraser-mode-controls,#erase-tool-dropdown>.mg-btn,#ai-tools-dropdown h5{transition:opacity .2s}#visuals-dropdown h5,#text-dropdown h5,#erase-tool-dropdown h5,#ai-tools-dropdown h5{margin:0 0 .5rem 0;font-size:1.25rem;text-align:center}#visuals-dropdown h6,#text-dropdown h6,#erase-tool-dropdown h6{font-size:1.15rem;font-weight:700;text-align:left;margin-top:.5rem;margin-bottom:.5rem;border-bottom:1px solid var(--mid);padding-bottom:2px}#visuals-dropdown label,#text-dropdown label,#erase-tool-dropdown label{display:block;margin-top:.5rem;font-size:1rem}#visuals-dropdown.is-scrubbing,#text-dropdown.is-scrubbing,#erase-tool-dropdown.is-scrubbing{background:transparent;backdrop-filter:none;-webkit-backdrop-filter:none;box-shadow:none;border-color:transparent}#visuals-dropdown.is-scrubbing>h5,#visuals-dropdown.is-scrubbing #visuals-tabs,#visuals-dropdown.is-scrubbing>div>div>h6,#visuals-dropdown.is-scrubbing .slider-container{opacity:0;pointer-events:none}#visuals-dropdown.is-scrubbing .slider-container.is-active-slider{opacity:1;pointer-events:auto}#text-dropdown.is-scrubbing>h5,#text-dropdown.is-scrubbing #text-layer-manager,#text-dropdown.is-scrubbing .slider-container{opacity:0;pointer-events:none}#text-dropdown.is-scrubbing .slider-container.is-active-slider{opacity:1;pointer-events:auto}#erase-tool-dropdown.is-scrubbing>h5,#erase-tool-dropdown.is-scrubbing .eraser-mode-selector,#erase-tool-dropdown.is-scrubbing #eraser-controls-wrapper{opacity:0;pointer-events:none}#erase-tool-dropdown.is-scrubbing #eraser-controls-wrapper.is-active-slider{opacity:1;pointer-events:auto}#visuals-dropdown input[type=range],#text-dropdown input[type=range],#erase-tool-dropdown input[type=range],#mg-eraser-hud input[type=range]{width:100%;-webkit-appearance:none;appearance:none;height:2px;background:var(--ink);outline:0}#visuals-dropdown input[type=range]::-webkit-slider-thumb,#text-dropdown input[type=range]::-webkit-slider-thumb,#erase-tool-dropdown input[type=range]::-webkit-slider-thumb,#mg-eraser-hud input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:16px;height:16px;background:var(--ink);border-radius:50%;cursor:pointer}#visuals-dropdown input[type=range]::-moz-range-thumb,#text-dropdown input[type=range]::-moz-range-thumb,#erase-tool-dropdown input[type=range]::-moz-range-thumb,#mg-eraser-hud input[type=range]::-moz-range-thumb{width:16px;height:16px;background:var(--ink);border-radius:50%;cursor:pointer;border:none}#asset-visuals-controls.disabled,#text-visuals-controls.disabled,#eraser-controls-wrapper.disabled{opacity:.5;pointer-events:none}.mg-btn{font-family:inherit;font-size:18px;background:var(--light);border:1px solid;border-color:var(--mid) var(--ink) var(--ink) var(--mid);padding:8px 16px;margin:4px;cursor:pointer;text-decoration:none;color:var(--ink);transition:all .2s;transform:translateY(-2px);border-radius:3px}.mg-btn:hover{filter:brightness(1.1);transform:translateY(-3px)}.mg-btn:disabled,.mg-btn.disabled{opacity:.5;pointer-events:none;transform:none;border-color:var(--mid)}.mg-btn:active,.mg-btn.active{transform:translateY(0);border-color:var(--ink) var(--mid) var(--mid) var(--ink);background-color:var(--danger-color);color:var(--light)}.mg-btn.success{background-color:var(--success-color)}.mg-btn.generate{background-color:var(--ink);color:var(--light)}.mg-btn.generate:active{background-color:var(--ink);color:var(--light)}.hidden{display:none!important}#studio-container{display:grid;grid-template-columns:320px 1fr;grid-template-rows:minmax(0,1fr);gap:1.5rem;padding:1.5rem;flex-grow:1;min-height:0}#controls-panel{display:flex;flex-direction:column;gap:1rem;overflow-y:auto;min-height:0}#canvas-panel{display:flex;align-items:center;justify-content:center;border:1px solid var(--ink);background-color:var(--mid);position:relative;min-height:0;transition:background-color .5s ease-in-out;overflow:hidden}#controls-panel fieldset{background:var(--light);border:1px solid var(--ink);padding:.8rem;margin:0;text-align:left;transition:background-color .3s,border-color .3s,color .3s,opacity .3s;border-radius:3px}#controls-panel legend{font-size:1.2rem;font-weight:400;padding:0 .5rem;transition:color .3s;margin-left:.5rem;background:var(--light)}.placeholder-text{color:var(--mid);font-size:1.1rem;text-align:center;padding:1rem;width:100%}body[data-theme-is-dark=true] #layer-instructions{color:var(--ink)}#mg-asset-palette,#mg-local-asset-palette{display:flex;gap:.5rem;flex-wrap:wrap;min-height:70px;align-content:flex-start}.palette-slot,.layer-thumb{width:60px;height:60px;border:1px solid var(--ink);background:var(--light);cursor:pointer;position:relative;border-radius:3px;box-shadow:3px 3px 0 var(--ink);transform:translate(0,0);transition:transform .15s ease-out,box-shadow .15s ease-out}.palette-slot.empty{display:flex;align-items:center;justify-content:center;font-size:3rem;line-height:1;color:var(--mid)}.layer-thumb:hover,.palette-slot.empty:hover{transform:translate(-2px,-2px);box-shadow:5px 5px 0 var(--ink)}.layer-thumb.active{transform:translate(1px,1px);box-shadow:none;border:2px solid var(--action-color)}.layer-thumb{cursor:grab}.layer-thumb img{width:100%;height:100%;object-fit:cover;pointer-events:none}.layer-controls{position:absolute;top:-5px;right:-5px;display:flex;gap:2px}.layer-btn{background-color:var(--danger-color);border:1px solid var(--ink);color:#fff;font-size:.8rem;font-weight:700;line-height:1;padding:1px 4px;cursor:pointer;width:18px;height:18px;text-align:center}#mg-movie-canvas,#mg-controls-overlay-canvas,#mg-pasteboard-overlay-canvas{position:absolute}#mg-controls-overlay-canvas,#mg-pasteboard-overlay-canvas{pointer-events:none}#mg-movie-canvas{pointer-events:auto}.mg-overlay-base{position:fixed;top:0;left:0;width:100%;height:100%;z-index:1000;display:none;align-items:center;justify-content:center;opacity:0;visibility:hidden;pointer-events:none;transition:opacity .3s,visibility 0s .3s;background:rgba(10,10,10,.25)}.mg-overlay-base.visible{opacity:1;visibility:visible;pointer-events:auto;transition:opacity .3s,visibility 0s 0s;display:flex}.overlay-close-btn{position:absolute;top:8px;right:10px;background:0 0;border:none;line-height:1;cursor:pointer;padding:5px;font-family:'VT323',monospace;color:var(--ink);font-size:2rem;z-index:10;transition:opacity .2s}.overlay-close-btn:hover{opacity:.6}#mg-asset-picker-grid-wrapper,#mg-local-asset-folder-wrapper{background:var(--light);border:1px solid var(--ink);box-shadow:2px 2px 0 var(--shadow);padding:1.5rem;max-width:800px;width:90vw;max-height:85vh;display:flex;flex-direction:column;position:relative;transition:max-width .3s ease-in-out}#mg-asset-picker-grid-wrapper h4,#mg-local-asset-folder-wrapper h4{font-size:1.5rem;text-align:center;font-weight:400;margin:0 0 1rem}#mg-asset-picker-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(80px,1fr));gap:.5rem;overflow-y:auto;padding:.5rem;flex-grow:1}#mg-asset-picker-actions{margin-top:1rem;text-align:center;display:flex;gap:.5rem;justify-content:center}#mg-local-asset-grid,#mg-local-asset-grid-assets,#mg-local-asset-grid-backgrounds{display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:1rem;overflow-y:auto;padding:1rem;flex-grow:1}.mg-template{position:relative;aspect-ratio:1/1;border:1px solid var(--mid);background-color:var(--bg);box-shadow:3px 3px 0 var(--ink);transition:transform .15s ease-out,box-shadow .15s ease-out;border-radius:3px}.mg-template:hover{transform:translate(-2px,-2px) scale(1.03);box-shadow:5px 5px 0 var(--ink)}.mg-template img{display:block;width:100%;height:100%;object-fit:cover;cursor:pointer}.mg-template .layer-btn.delete{position:absolute;top:4px;right:4px;z-index:5;width:22px;height:22px;font-size:1rem;display:flex;align-items:center;justify-content:center;border-radius:2px}.mg-btn.tab{color:var(--ink);opacity:.7;background:transparent;box-shadow:1px 1px 0 var(--shadow);transform:translateY(0);transition:transform .1s ease,box-shadow .1s ease,background-color .2s,opacity .2s}.mg-btn.tab:hover{opacity:1;transform:translateY(-1px);box-shadow:1px 1px 0 var(--shadow)}.mg-btn.tab.active{background-color:var(--mid);opacity:1;transform:translateY(1px);box-shadow:0 0 0 var(--shadow)}#mg-toast{visibility:hidden;position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:var(--light);border:1px solid var(--ink);padding:.5rem 1rem;color:var(--ink);font-size:1rem;z-index:2000;box-shadow:2px 2px 0 var(--shadow)}#canvas-placeholder{position:absolute;width:calc(100% - 20px);height:calc(100% - 20px);border:2px dashed var(--mid);border-radius:10px;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;cursor:pointer;color:var(--mid);transition:all .2s;padding:2rem;overflow:hidden;position:relative}#canvas-placeholder h3,#canvas-placeholder p{position:relative;z-index:2}#canvas-placeholder img{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;z-index:1;opacity:.6}#canvas-placeholder h3{font-size:2.2rem;margin:0 0 .5rem}#canvas-placeholder p{font-size:1.3rem}#canvas-placeholder:hover,#canvas-panel.drag-over #canvas-placeholder{border-color:var(--ink);color:var(--ink);background-color:rgba(255,255,255,.5)}#canvas-panel.drag-over{background-color:var(--shadow)}#layer-instructions{padding:0 0 .5rem 0;margin:0;font-size:1.1rem}#mg-confirmation-overlay,#mg-asset-action-overlay{z-index:5000}#mg-confirmation-dialog,#mg-asset-action-dialog{padding:1.5rem;text-align:center;width:90%;max-width:400px;height:auto}#mg-confirmation-dialog p,#mg-asset-action-dialog p{font-size:1.2rem;margin:0 0 1.5rem}#mg-confirmation-dialog .action-buttons,#mg-asset-action-dialog .action-buttons{display:flex;justify-content:center;gap:.5rem}#text-content,#text-font{transition:background-color .3s,border-color .3s,color .3s}#text-layer-manager{display:flex;gap:.5rem;align-items:center;padding-bottom:.5rem;margin-bottom:.5rem;border-bottom:1px solid var(--mid)}#text-layer-palette{display:flex;gap:.5rem;flex-wrap:wrap;flex-grow:1;min-height:44px}#add-new-text-layer-btn{width:40px;height:40px;flex-shrink:0;font-size:2rem;line-height:1;padding:0}.text-thumb{width:60px;height:40px;display:flex;align-items:center;justify-content:center;overflow:hidden;background-color:var(--ink);color:var(--light);font-size:.8rem;padding:2px;text-align:center}.text-thumb span{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;pointer-events:none}.palette-slot.empty:disabled{opacity:.4;cursor:default;pointer-events:none;background-color:var(--light)}.palette-slot.empty:disabled:hover{background-color:var(--light);color:var(--mid)}#shortcuts-btn:disabled,#visuals-btn:disabled,#text-btn:disabled,#erase-tool-btn:disabled,#ai-tools-btn:disabled{opacity:.5;pointer-events:none;cursor:default}.layer-thumb.dragging{opacity:.4;transform:rotate(-3deg) scale(1.05);box-shadow:0 8px 20px rgba(0,0,0,.3);cursor:grabbing}.layer-thumb.drag-over{border:3px dashed var(--action-color);transform:scale(1.02);background-color:rgba(var(--action-color-rgb),.1)}#mg-pasteboard-overlay-canvas{position:absolute;pointer-events:none;display:none}#canvas-panel.is-zoomed-out{background-color:var(--shadow)}#mg-movie-canvas,#mg-controls-overlay-canvas,#mg-pasteboard-overlay-canvas{transition:transform .3s ease-in-out,box-shadow .3s ease-in-out}#canvas-panel.is-zoomed-out #mg-movie-canvas,#canvas-panel.is-zoomed-out #mg-controls-overlay-canvas,#canvas-panel.is-zoomed-out #mg-pasteboard-overlay-canvas{transform:scale(.8);box-shadow:0 0 15px rgba(0,0,0,.5)}#canvas-panel.is-zoomed-out #mg-controls-overlay-canvas{display:none}#canvas-panel.is-zoomed-out #mg-pasteboard-overlay-canvas{display:block}#toggle-view-btn:disabled,#toggle-view-btn:disabled:hover{opacity:.5;pointer-events:none;cursor:default}.effects-checkbox{display:flex;align-items:center;margin-top:.5rem}.effects-checkbox input{margin-right:.5rem}.effects-controls{padding-left:1.5rem;border-left:1px solid var(--mid);margin-left:.5rem}.effects-controls.disabled{opacity:.5;pointer-events:none}#erase-tool-btn.active{background-color:var(--action-color);color:var(--light)}#mg-movie-canvas.erase-cursor{cursor:none}#erase-tool-dropdown .mg-btn{margin-top:.5rem}.eraser-mode-selector{display:flex;gap:.5rem;margin-bottom:.5rem}.eraser-mode-selector .mg-btn{width:50%;margin:0;padding:4px 8px;font-size:16px}.eraser-mode-selector .mg-btn:active,.eraser-mode-selector .mg-btn.active{background-color:var(--action-color);color:var(--light);transform:none;box-shadow:inset 1px 1px 0 rgba(0,0,0,.2)}#assets-folder-actions{display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem}#assets-folder-actions p{font-size:1.1rem;margin:0}#assets-folder-fieldset.disabled legend{color:var(--shadow)}#mg-eraser-zoom,#mg-eraser-hud{position:absolute;z-index:5;opacity:0;visibility:hidden;pointer-events:none;transition:opacity .2s,visibility 0s .2s}#mg-eraser-zoom.visible,#mg-eraser-hud.visible{opacity:1;visibility:visible;pointer-events:auto;transition:opacity .2s,visibility 0s 0s}#mg-eraser-zoom{right:12px;bottom:12px;width:160px;height:160px;border:1px solid var(--ink);background:var(--light);box-shadow:2px 2px 0 var(--shadow)}#mg-eraser-hud{right:12px;bottom:184px;background:var(--light);border:1px solid var(--ink);padding:6px 8px;box-shadow:2px 2px 0 var(--shadow);z-index:6;transition:background .2s,border-color .2s,box-shadow .2s,opacity .2s,visibility 0s .2s}#mg-eraser-hud .row{display:flex;align-items:center;gap:.5rem;transition:opacity .2s}#mg-eraser-hud button{font-family:inherit;font-size:14px;background:transparent;color:var(--ink);border:1px solid var(--ink);padding:2px 8px;cursor:pointer;box-shadow:1px 1px 0 var(--shadow)}#mg-eraser-hud.is-scrubbing{background:transparent;border-color:transparent;box-shadow:none}#mg-eraser-hud.is-scrubbing .row{opacity:0;pointer-events:none}#mg-eraser-hud.is-scrubbing .row.is-active-slider{opacity:1;pointer-events:auto}footer{padding:.5rem 1.5rem;display:flex;justify-content:space-between;align-items:center;font-size:.9rem;flex-shrink:0;flex-wrap:wrap;gap:1rem;background-color:var(--light);color:var(--ink);transition:background-color .3s,color .3s;border-top:none}.footer-links,.footer-right{display:flex;flex-wrap:wrap;gap:1.5rem;align-items:center}footer a{color:var(--ink);text-decoration:none;transition:opacity .2s;opacity:.7}footer a:hover{opacity:1}footer a i{margin-right:.5em}@media (max-width:980px){footer{justify-content:center}}#theme-popup-overlay,#border-style-popup-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.5);backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);display:none;justify-content:center;align-items:center;z-index:7000}#theme-popup-content,#border-style-popup-content{background:var(--bg);border:1px solid var(--ink);box-shadow:2px 2px 0 var(--shadow);padding:1rem;width:90%;max-width:400px;max-height:80vh;display:flex;flex-direction:column;transition:background-color .3s}#theme-list{list-style:none;margin:0;padding:0;overflow-y:auto}#theme-list li{padding:.75rem 1rem;cursor:pointer;display:flex;justify-content:space-between;align-items:center;transition:background-color .2s;border-radius:4px}#theme-list li.active{background-color:var(--action-color);color:var(--light)}#theme-list li.active::before{content:'✓';margin-right:.5rem}#theme-list li:not(.active):hover{background-color:var(--mid)}.theme-colors{display:flex;gap:.5rem}.theme-color-dot{width:16px;height:16px;border-radius:50%;border:1px solid var(--ink)}#version-popup-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.7);backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);display:none;justify-content:center;align-items:center;z-index:6000}#version-popup-content{background-color:var(--bg);padding:2rem;border:1px solid var(--ink);box-shadow:2px 2px 0 var(--shadow);width:80%;height:80%;max-width:800px;position:relative;color:var(--ink);overflow-y:auto}#version-popup-content h4{font-size:2rem;margin-bottom:.5rem}#version-popup-content h6{font-size:1rem;margin-top:0;opacity:.7;margin-bottom:1.5rem}#version-popup-content h5{font-size:1.5rem;margin-top:1.5rem;border-bottom:1px solid var(--mid);padding-bottom:.25rem}#version-popup-content ul{list-style:none;padding-left:0}#version-popup-content li{margin-bottom:.75rem;line-height:1.4}#close-popup{position:absolute;top:1rem;right:1.5rem;font-size:2rem;color:var(--ink);cursor:pointer;font-family:'VT323',monospace;line-height:1;transition:opacity .2s}#close-popup:hover{opacity:.6}#custom-font-select{position:relative}#font-select-trigger{background:var(--bg);border:1px solid var(--ink);padding:4px 8px;font-size:1rem;cursor:pointer;display:flex;justify-content:space-between;align-items:center;transition:background-color .3s,border-color .3s}#font-select-trigger:focus,#custom-font-select.open #font-select-trigger{border-color:var(--action-color)}#font-select-trigger span{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}#font-select-trigger i{transition:transform .2s ease-in-out;font-size:.8em}#custom-font-select.open #font-select-trigger i{transform:rotate(180deg)}#font-select-dropdown{position:absolute;top:calc(100% + 2px);left:0;right:0;background:var(--light);border:1px solid var(--ink);z-index:101;max-height:250px;overflow-y:auto;box-shadow:2px 2px 0 var(--shadow)}#font-select-list{list-style:none;margin:0;padding:0}#font-select-list li{padding:6px 10px;cursor:pointer;transition:background-color .2s;white-space:nowrap;font-size:.9rem}#font-select-list li:hover,#font-select-list li.hover-preview{background-color:var(--mid)}#font-select-list li.selected{background-color:var(--action-color);color:var(--light)}#mg-selection-box{position:absolute;pointer-events:none;display:flex;align-items:center;justify-content:center;font-family:'Courier New',Courier,monospace;font-size:1.2rem;background:transparent;transition:box-shadow .2s ease-in-out,filter .2s ease-in-out,opacity .2s ease-in-out;visibility:hidden;opacity:0;z-index:10}#mg-selection-box.visible{visibility:visible;opacity:1}#mg-selection-box .resizer,#mg-selection-box .rotater{position:absolute;z-index:11;pointer-events:auto}.style-box1{filter:url(#filter-crayon-classic);border:5px double #0f0;border-radius:4% 2% 6% 3%/3% 5% 2% 4%;box-shadow:2px 3px 6px rgba(0,0,0,.2)}.style-box1 .resizer{width:14px;height:14px;background:#0f0;border-radius:30% 70% 70% 30%/30% 30% 70% 70%;top:-9px;left:-9px;cursor:nwse-resize}.style-box1 .resizer.top-right{right:-9px;left:auto;cursor:nesw-resize}.style-box1 .resizer.bottom-left{bottom:-9px;top:auto;cursor:nesw-resize}.style-box1 .resizer.bottom-right{bottom:-9px;top:auto;right:-9px;left:auto;cursor:nwse-resize}.style-box1 .rotater{top:-40px;left:50%;transform:translateX(-50%);width:28px;height:28px;cursor:grab}.style-box1 .rotater:active{cursor:grabbing}.style-box1 .rotater svg{filter:url(#filter-crayon-classic)}.style-box1 .rotater svg,.style-box1 .rotater svg *{fill:#0f0}.style-box2{border:2px solid #0f0;box-shadow:2px 3px 6px rgba(0,0,0,.2)}.style-box2 .resizer{width:16px;height:16px;top:-8px;left:-8px;cursor:nwse-resize}.style-box2 .resizer::before,.style-box2 .resizer::after{content:'';position:absolute;top:50%;left:50%;width:2px;height:14px;background:#0f0;transform-origin:center}.style-box2 .resizer::before{transform:translate(-50%,-50%) rotate(45deg)}.style-box2 .resizer::after{transform:translate(-50%,-50%) rotate(-45deg)}.style-box2 .resizer.top-right{right:-8px;left:auto;cursor:nesw-resize}.style-box2 .resizer.bottom-left{bottom:-8px;top:auto;cursor:nesw-resize}.style-box2 .resizer.bottom-right{bottom:-8px;top:auto;right:-8px;left:auto;cursor:nwse-resize}.style-box2 .rotater{top:-38px;left:50%;transform:translateX(-50%);width:24px;height:24px;cursor:grab}.style-box2 .rotater:active{cursor:grabbing}.style-box2 .rotater svg,.style-box2 .rotater svg *{fill:#0f0}.style-box3{border:3px solid #0f0;filter:url(#filter-vine);border-radius:5px;box-shadow:2px 3px 6px rgba(0,0,0,.2)}.style-box3 .resizer{width:18px;height:18px;top:-9px;left:-9px;cursor:nwse-resize}.style-box3 .resizer.top-right{right:-9px;left:auto;cursor:nesw-resize}.style-box3 .resizer.bottom-left{bottom:-9px;top:auto;cursor:nesw-resize}.style-box3 .resizer.bottom-right{bottom:-9px;top:auto;right:-9px;left:auto;cursor:nwse-resize}.style-box3 .rotater{top:-38px;left:50%;transform:translateX(-50%);width:24px;height:24px;cursor:grab}.style-box3 .rotater:active{cursor:grabbing}.style-box3 .rotater svg{filter:url(#filter-vine)}.style-box3 .rotater svg,.style-box3 .rotater svg *{fill:#0f0}.style-box4{filter:url(#filter-wiggle);border:2px solid #0f0;border-radius:2% 4% 3% 5%/3% 2% 5% 4%;box-shadow:2px 3px 6px rgba(0,0,0,.2)}.style-box4 .resizer{width:12px;height:12px;background:#0f0;border-radius:50%;top:-6px;left:-6px;cursor:nwse-resize}.style-box4 .resizer.top-right{right:-6px;left:auto;cursor:nesw-resize}.style-box4 .resizer.bottom-left{bottom:-6px;top:auto;cursor:nesw-resize}.style-box4 .resizer.bottom-right{bottom:-6px;top:auto;right:-6px;left:auto;cursor:nwse-resize}.style-box4 .rotater{top:-35px;left:50%;transform:translateX(-50%);width:22px;height:22px;cursor:grab}.style-box4 .rotater:active{cursor:grabbing}.style-box4 .rotater svg{filter:url(#filter-wiggle)}.style-box4 .rotater svg,.style-box4 .rotater svg *{stroke:#0f0;fill:none}#border-style-popup-content{max-width:550px;width:90vw}.border-style-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:3.5rem 2rem;justify-content:center;padding:2rem 2rem 4rem}.border-box-container{position:relative;height:120px;display:flex;align-items:center;justify-content:center;cursor:pointer}.border-box-preview{position:relative;width:150px;height:90px;transition:transform .2s,box-shadow .2s;background:var(--mid)}.border-box-container:hover .border-box-preview{transform:scale(1.05)}.border-box-label{position:absolute;bottom:-3rem;left:50%;transform:translateX(-50%);font-size:.9rem;color:var(--ink);white-space:nowrap;background:var(--bg);padding:4px 10px;text-align:center;border:1px solid var(--shadow)}.border-box-label strong{display:block;margin-bottom:4px;font-size:1rem}.border-box-container.active .border-box-label{border-color:var(--action-color);box-shadow:2px 2px 0 var(--action-color)}.border-box-container.active .border-box-preview{transform:scale(1.02)}.border-box-preview.style-box1{border-color:var(--ink)}.border-box-preview.style-box2{border-color:var(--ink)}.border-box-preview.style-box3{border-color:var(--ink)}.border-box-preview.style-box4{border-color:var(--ink)}.border-box-preview.style-box2 .corner-x{position:absolute;width:12px;height:12px;color:var(--ink);font-size:18px;line-height:12px;font-weight:700;text-align:center;font-family:'Courier New',monospace}.border-box-preview.style-box2 .corner-x::before{content:'×'}.corner-x.top-left{top:-8px;left:-8px}.corner-x.top-right{top:-8px;right:-8px}.corner-x.bottom-left{bottom:-8px;left:-8px}.corner-x.bottom-right{bottom:-8px;right:-8px}`;
            const style = document.createElement('style');
            style.textContent = nonCriticalCSS;
            document.head.appendChild(style);
        }

        // --- THEME SELECTOR LOGIC (UPDATED) ---
        const themes = {
            'classic light': { name: 'classic light', isDark: false, colors: ['#f2efe8', '#2b2b2b', '#c2c2c2'], css: { '--bg': '#f2efe8', '--ink': '#2b2b2b', '--mid': '#c2c2c2', '--light': '#faf9f5', '--shadow': '#7a7a7a', '--action-color': '#4477cc', '--danger-color': '#cc4444', '--success-color': '#55cc55' } },
            'dark': { name: 'dark', isDark: true, colors: ['#1a1d2d', '#e0e5f0', '#5a8de8'], css: { '--bg': '#1a1d2d', '--ink': '#e0e5f0', '--mid': '#3d4a6e', '--light': '#252a40', '--shadow': '#0d0f16', '--action-color': '#5a8de8', '--danger-color': '#a83e3e', '--success-color': '#4a9d4a' } },
            'イーピーイッピ': { name: 'イーピーイッピ', isDark: true, colors: ['#5c3d46', '#dcd0c0', '#a26769'], css: { '--bg': '#2a1d21', '--ink': '#dcd0c0', '--mid': '#5c3d46', '--light': '#402d32', '--shadow': '#1a1114', '--action-color': '#a26769', '--danger-color': '#a26769', '--success-color': '#69a267' } },
            'zarah': { name: 'zarah', isDark: false, colors: ['#7b9c98', '#eaf1f3', '#495555'], css: { '--bg': '#7b9c98', '--ink': '#eaf1f3', '--mid': '#495755', '--light': '#6c8985', '--shadow': '#3e4a48', '--action-color': '#eaf1f3' } },
            'denim': { name: 'denim', isDark: true, colors: ['#282a36', '#f8f82', '#bd93f9'], css: { '--bg': '#282a36', '--ink': '#f8f8f2', '--mid': '#44475a', '--light': '#383a59', '--shadow': '#21222c', '--action-color': '#bd93f9' } },
            'lavender': { name: 'lavender', isDark: false, colors: ['#b3b3d9', '#282846', '#656599'], css: { '--bg': '#b3b3d9', '--ink': '#282846', '--mid': '#656599', '--light': '#c4c4e2', '--shadow': '#47476b', '--action-color': '#8c58a6' } },
            'café': { name: 'café', isDark: false, colors: ['#ceb18d', '#4e433f', '#d4d2d1'], css: { '--bg': '#ceb18d', '--ink': '#4e433f', '--mid': '#d4d2d1', '--light': '#f7f2ea', '--shadow': '#8a7a6a', '--action-color': '#8a6ea2' } },
            'mizu': { name: 'mizu', isDark: false, colors: ['#b8dceb', '#091f2c', '#89a5bb'], css: { '--bg': '#b8dceb', '--ink': '#091f2c', '--mid': '#89a5bb', '--light': '#cfe5ee', '--shadow': '#627382', '--action-color': '#005a8e' } },
            'キティ': { name: 'キティ', isDark: false, colors: ['#fdf6e3', '#657b83', '#93a1a1'], css: { '--bg': '#fdf6e3', '--ink': '#657b83', '--mid': '#93a1a1', '--light': '#eee8d5', '--shadow': '#586e75', '--action-color': '#268bd2' } },
            'aura': { name: 'aura', isDark: true, colors: ['#29423D', '#EAE8E1', '#C9A59C'], css: { '--bg': '#1A2A27', '--ink': '#EAE8E1', '--mid': '#3E5D56', '--light': '#29423D', '--shadow': '#111C19', '--action-color': '#C9A59C', '--danger-color': '#b05454', '--success-color': '#5a9e7a' } },
        };

        const themePopupOverlay = document.getElementById('theme-popup-overlay');
        const themePopupContent = document.getElementById('theme-popup-content');
        const themeList = document.getElementById('theme-list');
        const themeSelectLink = document.getElementById('theme-select-link');
        const currentThemeNameSpan = document.getElementById('current-theme-name');
        let originalTheme = 'classic light';
        let themeChosen = false;
        
        // --- Variable Declarations ---
        const assetLibraryOverlay = document.getElementById('mg-asset-library-overlay');
        const assetPalette = document.getElementById('mg-asset-palette');
        const assetPickerFileInput = document.getElementById('mg-asset-picker-file');
        const canvasPanel = document.getElementById('canvas-panel');
        const canvasPlaceholder = document.getElementById('canvas-placeholder');
        const controlsOverlayCanvas = document.getElementById('mg-controls-overlay-canvas');
        const controlsCtx = controlsOverlayCanvas.getContext('2d');
        const pasteboardOverlayCanvas = document.getElementById('mg-pasteboard-overlay-canvas');
        const pasteboardCtx = pasteboardOverlayCanvas.getContext('2d');
        const selectionBox = document.getElementById('mg-selection-box');
        const PASTEBOARD_MARGIN = 1500;
        const initialBackgroundInput = document.getElementById('initial-background-input');
        const layerInstructions = document.getElementById('layer-instructions');
        const movieCanvas = document.getElementById('mg-movie-canvas');
        const movieCtx = movieCanvas.getContext('2d');
        const downloadImageBtn = document.getElementById('mg-download-image-btn');
        const clearCanvasBtn = document.getElementById('mg-clear-canvas-btn');
        const confirmationOverlay = document.getElementById('mg-confirmation-overlay');
        const confirmationText = document.getElementById('mg-confirmation-text');
        const confirmYesBtn = document.getElementById('mg-confirm-yes-btn');
        const confirmNoBtn = document.getElementById('mg-confirm-no-btn');
        const shortcutsBtn = document.getElementById('shortcuts-btn');
        const shortcutsDropdown = document.getElementById('shortcuts-dropdown');
        const visualsBtn = document.getElementById('visuals-btn');
        const visualsDropdown = document.getElementById('visuals-dropdown');
        const assetVisualsControls = document.getElementById('asset-visuals-controls');
        const assetOpacitySlider = document.getElementById('asset-opacity');
        const assetBrightnessSlider = document.getElementById('asset-brightness');
        const assetSaturationSlider = document.getElementById('asset-saturation');
        const bgBrightnessSlider = document.getElementById('bg-brightness');
        const bgSaturationSlider = document.getElementById('bg-saturation');
        const textBtn = document.getElementById('text-btn');
        const textDropdown = document.getElementById('text-dropdown');
        const textVisualsControls = document.getElementById('text-visuals-controls');
        const textContentInput = document.getElementById('text-content');
        const textSizeSlider = document.getElementById('text-size');
        const textColorInput = document.getElementById('text-color');
        const textEdgeColorInput = document.getElementById('text-edge-color');
        const textEdgeWidthSlider = document.getElementById('text-edge-width');
        const addNewTextLayerBtn = document.getElementById('add-new-text-layer-btn');
        const textLayerPalette = document.getElementById('text-layer-palette');
        const toggleViewBtn = document.getElementById('toggle-view-btn');
        const eraseToolBtn = document.getElementById('erase-tool-btn');
        const eraseToolDropdown = document.getElementById('erase-tool-dropdown');
        const eraserControlsWrapper = document.getElementById('eraser-controls-wrapper');
        const eraserSizeSlider = document.getElementById('eraser-size');
        const eraserOpacitySlider = document.getElementById('eraser-opacity');
        const undoEraseBtn = document.getElementById('undo-erase-btn');
        const revertErasingBtn = document.getElementById('revert-erasing-btn');
        const eraseBtn = document.getElementById('erase-btn');
        const uneraseBtn = document.getElementById('unerase-btn');
        const aiToolsBtn = document.getElementById('ai-tools-btn');
        const aiToolsDropdown = document.getElementById('ai-tools-dropdown');
        const assetsFolderFieldset = document.getElementById('assets-folder-fieldset');
        const localAssetPalette = document.getElementById('mg-local-asset-palette');
        const viewAllLocalAssetsBtn = document.getElementById('mg-view-all-local-assets-btn');
        const localAssetFolderOverlay = document.getElementById('mg-local-asset-folder-overlay');
        const localAssetFolderWrapper = document.getElementById('mg-local-asset-folder-wrapper');
        const localAssetGridAssets = document.getElementById('mg-local-asset-grid-assets');
        const localAssetGridBackgrounds = document.getElementById('mg-local-asset-grid-backgrounds');
        const tabAssetsBtn = document.getElementById('tab-assets');
        const tabBackgroundsBtn = document.getElementById('tab-backgrounds');
        const localAssetFolderCloseBtn = document.getElementById('mg-local-asset-folder-close');
        
        const visualsTabAssetBtn = document.getElementById('visuals-tab-asset');
        const visualsTabBackgroundBtn = document.getElementById('visuals-tab-background');
        const assetTabPanel = document.getElementById('asset-tab-panel');
        const backgroundTabPanel = document.getElementById('background-tab-panel');

        const customFontSelect = document.getElementById('custom-font-select');
        const fontSelectTrigger = document.getElementById('font-select-trigger');
        const fontSelectDropdown = document.getElementById('font-select-dropdown');
        const fontSelectList = document.getElementById('font-select-list');
        let originalFontOnHover = null;
        const availableFonts = [
            { name: 'VT323', value: "'VT323', monospace" }, { name: 'Roboto', value: "'Roboto', sans-serif" }, { name: 'Anton', value: "'Anton', sans-serif" }, { name: 'Indie Flower', value: "'Indie Flower', cursive" }, { name: 'Londrina Outline', value: "'Londrina Outline', cursive" }, { name: 'Patua One', value: "'Patua One', cursive" }, { name: 'Pixelify Sans', value: "'Pixelify Sans', sans-serif" }, { name: 'Press Start 2P', value: "'Press Start 2P', cursive", style: "font-size: 0.6rem;" }, { name: 'Rubik Mono One', value: "'Rubik Mono One', sans-serif" }, { name: 'Young Serif', value: "'Young Serif', serif" }, { name: 'Arial', value: "Arial, sans-serif" }, { name: 'Verdana', value: "Verdana, sans-serif" }, { name: 'Georgia', value: "Georgia, serif" }, { name: 'Times New Roman', value: "Times New Roman, serif" }, { name: 'Courier New', value: "Courier New, monospace" }, { name: 'Impact', value: "Impact, fantasy" }, { name: 'Comic Sans MS', value: "Comic Sans MS, cursive" }
        ];

        const UI_MIN_PX = 120, UI_MAX_PX = 220, TARGET_RADIUS_PX = 34, MIN_MARGIN_PREVIEW = 12, MIN_ZOOM_FEEL = 1.08, BRUSH_MIN = 5, BRUSH_MAX = 200, MAX_UNDO_STACK = 10;
        let lastEraseCanvasPoint = null;

        const eraserZoomCanvas = document.getElementById('mg-eraser-zoom');
        const eraserZoomCtx = eraserZoomCanvas.getContext('2d');
        const eraserHud = document.getElementById('mg-eraser-hud');
        const hudEraseBtn = document.getElementById('mg-hud-erase-btn');
        const hudUneraseBtn = document.getElementById('mg-hud-unerase-btn');
        const eraserSizeMini = document.getElementById('mg-eraser-size-mini');
        const eraserStrengthMini = document.getElementById('mg-eraser-strength-mini');
        
        let toastTimeout;
        let toastAnimationInterval = null;
        const toastEl = document.getElementById('mg-toast');
        
        let canvasState = { backgroundElement: null, backgroundType: 'none', bgBrightness: 1, bgSaturation: 1, layers: [] };

        const assetCache = {};
        let activeLayerId = null;
        let movieInteraction = { active: false };
        let animationFrameId = null;
        const FADE_IN_DURATION = 300;
        let isAnimatingRender = false;
        let masterWidth = 1280, masterHeight = 720;
        let isCanvasViewZoomedOut = false;
        let eraserMode = 'none', isEraserArmed = false;
        let eraseBrushPos = { x: 0, y: 0 };
        
        const getActiveLayer = () => canvasState.layers.find(l => l.id === activeLayerId);

        function applyTheme(themeName, isPreview = false) {
            const theme = themes[themeName];
            if (!theme) return;
            const root = document.documentElement;
            if (isPreview) { root.style.transition = 'none'; }
            for (const [key, value] of Object.entries(theme.css)) {
                root.style.setProperty(key, value);
                if (key === '--light') root.style.setProperty('--light-rgb', hexToRgb(value));
                if (key === '--bg') root.style.setProperty('--bg-rgb', hexToRgb(value));
                if (key === '--action-color') root.style.setProperty('--action-color-rgb', hexToRgb(value));
            }
            document.body.dataset.themeIsDark = theme.isDark;
            if (isPreview) { void root.offsetWidth; root.style.transition = ''; }
        }

        function hexToRgb(hex) {
            let r=0,g=0,b=0;
            if(hex.length==4){r=parseInt(hex[1]+hex[1],16);g=parseInt(hex[2]+hex[2],16);b=parseInt(hex[3]+hex[3],16)}
            else if(hex.length==7){r=parseInt(hex[1]+hex[2],16);g=parseInt(hex[3]+hex[4],16);b=parseInt(hex[5]+hex[6],16)}
            return `${r},${g},${b}`;
        }

        function saveAndApplyTheme(themeName) {
            themeChosen = true;
            applyTheme(themeName);
            localStorage.setItem('selectedTheme', themeName);
            originalTheme = themeName;
            currentThemeNameSpan.textContent = themeName;
            const currentActive = themeList.querySelector('.active');
            if (currentActive) currentActive.classList.remove('active');
            const newActive = themeList.querySelector(`[data-theme-name="${themeName}"]`);
            if (newActive) newActive.classList.add('active');
            themePopupOverlay.style.display = 'none';
        }

        function populateThemeList() {
            themeList.innerHTML = '';
            const currentTheme = localStorage.getItem('selectedTheme') || 'classic light';
            for (const themeName in themes) {
                const theme = themes[themeName];
                const li = document.createElement('li');
                li.dataset.themeName = themeName;
                if(themeName === currentTheme) li.classList.add('active');
                let content = `<span>${theme.name}</span>`;
                let colorDots = '<div class="theme-colors">';
                theme.colors.forEach(color => { colorDots += `<div class="theme-color-dot" style="background-color: ${color};"></div>`; });
                colorDots += '</div>';
                li.innerHTML = content + colorDots;
                li.addEventListener('click', () => saveAndApplyTheme(themeName));
                li.addEventListener('mouseenter', () => applyTheme(themeName, true));
                themeList.appendChild(li);
            }
        }
        
        const savedTheme = localStorage.getItem('selectedTheme') || 'classic light';
        originalTheme = savedTheme;
        applyTheme(savedTheme);
        currentThemeNameSpan.textContent = savedTheme;
        
        // --- BORDER STYLE LOGIC ---
        const borderStyles = [
            { id: 'style-box1', title: "Classic Crayon", desc: "A waxy, uneven, and tactile texture.", svg: `<svg viewBox="0 0 28 28"><path d="M14 2a12 12 0 1 0 0 24 12 12 0 0 0 0-24zm0 22a10 10 0 1 1 0 -20 10 10 0 0 1 0 20zm-2-8h4v-4h-4v4z"/></svg>` },
            { id: 'style-box2', title: "Classic Barb", desc: "Sharp, metallic, and defensive.", svg: `<svg viewBox="0 0 24 24"><path d="M12 0 L15 9 L24 9 L17 15 L20 24 L12 18 L4 24 L7 15 L0 9 L9 9 Z"/></svg>` },
            { id: 'style-box3', title: "Thorny Vine", desc: "An organic, natural take on sharpness.", svg: `<svg viewBox="0 0 24 24"><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><path d="M12 7a5 5 0 1 0 5 5 5 5 0 0 0-5-5z"/></svg>` },
            { id: 'style-box4', title: "Classic Wiggle", desc: "The original hand-drawn SVG turbulence.", svg: `<svg viewBox="0 0 22 22" stroke-width="2"><path d="M18 11 A7 7 0 1 1 11 4"/><path d="M18 7v4h-4"/></svg>` }
        ];
        const borderStylePopup = document.getElementById('border-style-popup-overlay');
        const borderStyleGrid = document.querySelector('.border-style-grid');
        const borderStyleLink = document.getElementById('border-style-link');
        const currentBorderStyleNameSpan = document.getElementById('current-border-style-name');
        let activeBorderStyle = 'style-box4';

        function applyBorderStyle(styleId) {
            activeBorderStyle = styleId;
            const styleName = borderStyles.find(s => s.id === styleId)?.title || 'Borders';
            currentBorderStyleNameSpan.textContent = styleName;
            if (getActiveLayer()) { drawControlsOverlay(); }
        }

        function saveAndApplyBorderStyle(styleId) {
            applyBorderStyle(styleId);
            localStorage.setItem('selectedBorderStyle', styleId);
            borderStyleGrid.querySelector('.active')?.classList.remove('active');
            borderStyleGrid.querySelector(`[data-style-id="${styleId}"]`)?.classList.add('active');
            borderStylePopup.style.display = 'none';
        }

        function populateBorderStylePopup() {
            borderStyleGrid.innerHTML = '';
            const currentStyle = localStorage.getItem('selectedBorderStyle') || 'style-box2';
            borderStyles.forEach(style => {
                const container = document.createElement('div');
                container.className = 'border-box-container';
                container.dataset.styleId = style.id;
                if (style.id === currentStyle) container.classList.add('active');
                
                let previewHTML = `<div class="border-box-preview ${style.id}">`;
                if (style.id === 'style-box2') {
                    previewHTML += `<div class="corner-x top-left"></div><div class="corner-x top-right"></div><div class="corner-x bottom-left"></div><div class="corner-x bottom-right"></div>`;
                }
                previewHTML += '</div>';

                container.innerHTML = previewHTML + `<div class="border-box-label"><strong>${style.title}</strong>${style.desc}</div>`;
                container.addEventListener('click', () => saveAndApplyBorderStyle(style.id));
                borderStyleGrid.appendChild(container);
            });
        }
        const savedBorderStyle = localStorage.getItem('selectedBorderStyle') || 'style-box4';
        applyBorderStyle(savedBorderStyle);
        
        // --- APP LOGIC ---
        function toast(message, duration = 3000) {
            if (!toastEl) return;
            clearTimeout(toastTimeout);
            clearInterval(toastAnimationInterval);
            toastEl.textContent = message;
            toastEl.style.visibility = 'visible';
            if (duration === null) {
                let dotCount = 1;
                const baseMessage = message;
                toastAnimationInterval = setInterval(() => {
                    const dots = '.'.repeat(dotCount);
                    toastEl.textContent = baseMessage + dots;
                    dotCount = (dotCount % 3) + 1;
                }, 400);
            } else {
                toastTimeout = setTimeout(() => {
                    toastEl.style.visibility = 'hidden';
                    clearInterval(toastAnimationInterval);
                }, duration);
            }
        }

        function hideToast() {
            if (!toastEl) return;
            clearTimeout(toastTimeout);
            clearInterval(toastAnimationInterval);
            toastEl.style.visibility = 'hidden';
        }

        async function sha256Hex(blob) {
            const buf = await blob.arrayBuffer();
            const digest = await crypto.subtle.digest('SHA-256', buf);
            const bytes = new Uint8Array(digest);
            return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function idbOpen(dbName = 'ims-db', store = 'assets') {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(dbName, 3);
                req.onupgradeneeded = () => {
                    const db = req.result;
                    let os;
                    if (!db.objectStoreNames.contains(store)) { os = db.createObjectStore(store, { keyPath: 'id', autoIncrement: true }); } 
                    else { os = req.transaction.objectStore(store); }
                    if (!os.indexNames.contains('createdAt')) os.createIndex('createdAt', 'createdAt');
                    if (!os.indexNames.contains('hash')) os.createIndex('hash', 'hash', { unique: false });
                    if (!os.indexNames.contains('kind')) os.createIndex('kind', 'kind', { unique: false });
                };
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }

        async function idbPut(record, dbName = 'ims-db', store = 'assets') {
            const db = await idbOpen(dbName, store);
            return new Promise((resolve, reject) => {
                const tx = db.transaction(store, 'readwrite');
                const req = tx.objectStore(store).put(record);
                req.onsuccess = () => { if (record.id == null) record.id = req.result; };
                tx.oncomplete = () => resolve(record);
                tx.onerror = () => reject(tx.error);
            });
        }

        async function idbGetAll(dbName = 'ims-db', store = 'assets') {
            const db = await idbOpen(dbName, store);
            return new Promise((resolve, reject) => {
                const tx = db.transaction(store, 'readonly');
                const req = tx.objectStore(store).getAll();
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }

        async function idbDelete(id, dbName = 'ims-db', store = 'assets') {
            const db = await idbOpen(dbName, store);
            return new Promise((resolve, reject) => {
                const tx = db.transaction(store, 'readwrite');
                tx.objectStore(store).delete(id);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }
        
        async function idbFindByHash(hash, dbName = 'ims-db', store = 'assets') {
            const db = await idbOpen(dbName, store);
            return new Promise((resolve, reject) => {
                const tx = db.transaction(store, 'readonly');
                const os = tx.objectStore(store);
                const idx = os.indexNames.contains('hash') ? os.index('hash') : null;
                if (!idx) return resolve([]);
                const req = idx.getAll(hash);
                req.onsuccess = () => resolve(req.result || []);
                req.onerror = () => reject(req.error);
            });
        }

        async function findDuplicatesIncludingHashless(targetHash) {
            let matches = await idbFindByHash(targetHash);
            const matchedIds = new Set(matches.map(m => m.id));
            const all = await idbGetAll();
            for (const rec of all) {
                if (matchedIds.has(rec.id)) continue;
                if (!rec.hash && rec.full) {
                    rec.hash = await sha256Hex(rec.full);
                    await idbPut(rec);
                    if (rec.hash === targetHash) { matches.push(rec); matchedIds.add(rec.id); }
                }
            }
            return matches;
        }

        async function dedupeExistingAssetsByHashKeepNewest() {
            const all = await idbGetAll();
            for (const rec of all) {
                if (!rec.hash && rec.full) { rec.hash = await sha256Hex(rec.full); await idbPut(rec); }
            }
            const byHash = new Map();
            for (const rec of await idbGetAll()) {
                if (!rec.hash) continue;
                const best = byHash.get(rec.hash);
                if (!best || rec.createdAt > best.createdAt) { byHash.set(rec.hash, rec); }
            }
            for (const rec of await idbGetAll()) {
                if (rec.hash && byHash.get(rec.hash).id !== rec.id) { await idbDelete(rec.id); }
            }
            await renderLocalAssetPalette_IDB();
        }

        async function toBlobFromDataURL(dataURL) { const res = await fetch(dataURL); return await res.blob(); }

        async function createThumbBlob(imgBlob, max = 256, type = 'image/webp', quality = 0.8) {
            try {
                const bmp = await createImageBitmap(imgBlob);
                const scale = Math.min(max / bmp.width, max / bmp.height, 1);
                const w = Math.round(bmp.width * scale);
                const h = Math.round(bmp.height * scale);
                const c = new OffscreenCanvas(w, h);
                c.getContext('2d').drawImage(bmp, 0, 0, w, h);
                return await c.convertToBlob({ type, quality });
            } catch (e) {
                console.error("Could not create thumbnail from blob, possibly a non-image type.", e);
                return await (await fetch('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8Xw8AAmMBb3eGmC0AAAAASUVORK5CYII=')).blob();
            }
        }
        
        async function saveAssetToLibrary({ dataURL, mime = 'image/png', kind = 'asset' }) {
            const fullBlob = await toBlobFromDataURL(dataURL);
            const hash = await sha256Hex(fullBlob);
            const thumbBlob = await createThumbBlob(fullBlob);
            const rec = { full: fullBlob, thumb: thumbBlob, mime, createdAt: Date.now(), hash, kind };
            await idbPut(rec);
            const dups = await findDuplicatesIncludingHashless(hash);
            for (const old of dups) { if (old.id !== rec.id) await idbDelete(old.id); }
            await enforceQuota(80 * 1024 * 1024);
            await renderLocalAssetPalette_IDB();
            if (localAssetFolderOverlay.classList.contains('visible')) { await renderFullLocalAssetFolder_IDB(); }
        }
        
        async function enforceQuota(limitBytes) {
            const assets = await idbGetAll();
            let totalBytes = assets.reduce((sum, r) => sum + (r.full.size || 0) + (r.thumb.size || 0), 0);
            if (totalBytes <= limitBytes) return;
            assets.sort((a,b) => a.createdAt - b.createdAt);
            for (const rec of assets) {
                if (totalBytes <= limitBytes) break;
                await idbDelete(rec.id);
                totalBytes -= (rec.full.size || 0) + (rec.thumb.size || 0);
                toast('Oldest asset removed to free space.', 3000);
            }
        }
        
        async function deleteAssetFromLibrary(assetId) {
            try {
                const idNum = typeof assetId === 'string' ? Number(assetId) : assetId;
                if (!Number.isFinite(idNum)) throw new Error(`Invalid asset id: ${assetId}`);
                await idbDelete(idNum);
                toast('Asset removed from folder.', 1500);
                await renderLocalAssetPalette_IDB();
                if (localAssetFolderOverlay.classList.contains('visible')) { await renderFullLocalAssetFolder_IDB(); }
            } catch (error) {
                console.error("Failed to delete asset:", error);
                toast("Error: Could not delete asset.", 4000);
            }
        }

        async function renderLocalAssetPalette_IDB() {
            const all = await idbGetAll();
            const assetsOnly = all.map(r => ({ ...r, kind: r.kind || 'asset' })).filter(r => r.kind === 'asset').sort((a, b) => b.createdAt - a.createdAt);
            localAssetPalette.innerHTML = '';
            const toShow = assetsOnly.slice(0, 4);
            for (const asset of toShow) {
                const thumb = document.createElement('div');
                thumb.className = 'layer-thumb';
                thumb.title = "Add asset as a new layer";
                const thumbUrl = URL.createObjectURL(asset.thumb);
                const img = new Image();
                img.src = thumbUrl;
                img.onload = () => URL.revokeObjectURL(thumbUrl);
                thumb.appendChild(img);
                thumb.addEventListener('click', () => {
                    if (!canvasState.backgroundElement) { toast('Please set a background before adding layers.', 2000); return; }
                    addImageLayer(URL.createObjectURL(asset.full));
                });
                localAssetPalette.appendChild(thumb);
            }
            if (assetsOnly.length === 0) { localAssetPalette.innerHTML = `<p class="placeholder-text" style="padding:0;line-height:1.2;">Your assets will appear here when you add layers.</p>`; }
        }

        function setLocalFolderTab(tab) {
            const isAssets = tab === 'assets';
            tabAssetsBtn.classList.toggle('active', isAssets);
            tabBackgroundsBtn.classList.toggle('active', !isAssets);
            localAssetGridAssets.classList.toggle('hidden', !isAssets);
            localAssetGridBackgrounds.classList.toggle('hidden', isAssets);
        }

        async function renderFullLocalAssetFolder_IDB() {
            const all = await idbGetAll();
            const normalized = all.map(r => ({ ...r, kind: r.kind || 'asset' }));
            const assets = normalized.filter(r => r.kind === 'asset').sort((a,b) => b.createdAt - a.createdAt);
            const bgs = normalized.filter(r => r.kind === 'background').sort((a,b) => b.createdAt - a.createdAt);
            const count = Math.max(assets.length, bgs.length);
            if (count < 8) localAssetFolderWrapper.style.maxWidth = '480px';
            else if (count < 16) localAssetFolderWrapper.style.maxWidth = '640px';
            else localAssetFolderWrapper.style.maxWidth = '800px';
            localAssetGridAssets.innerHTML = '';
            localAssetGridBackgrounds.innerHTML = '';
            if (assets.length === 0) { localAssetGridAssets.innerHTML = `<p class="placeholder-text">No saved assets yet. Upload an image as a layer to save it here.</p>`; }
            if (bgs.length === 0) { localAssetGridBackgrounds.innerHTML = `<p class="placeholder-text">No saved backgrounds yet. Upload a background to save it here.</p>`; }
            for (const rec of assets) {
                const div = document.createElement('div');
                div.className = 'mg-template';
                div.dataset.assetId = String(rec.id);
                const thumbUrl = URL.createObjectURL(rec.thumb);
                div.innerHTML = `<img src="${thumbUrl}" alt="Asset"><div class="layer-btn delete" title="Remove from folder">x</div>`;
                const img = div.querySelector('img');
                img.onload = () => URL.revokeObjectURL(thumbUrl);
                img.addEventListener('click', () => {
                    if (!canvasState.backgroundElement) { toast('Please set a background before adding layers.', 2000); localAssetFolderOverlay.classList.remove('visible'); return; }
                    addImageLayer(URL.createObjectURL(rec.full));
                    localAssetFolderOverlay.classList.remove('visible');
                });
                div.querySelector('.delete').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const idNum = Number(div.dataset.assetId);
                    openConfirmationModal('Remove this asset from your local folder?', async () => { div.remove(); await deleteAssetFromLibrary(idNum); });
                });
                localAssetGridAssets.appendChild(div);
            }
            for (const rec of bgs) {
                const div = document.createElement('div');
                div.className = 'mg-template';
                div.dataset.assetId = String(rec.id);
                const thumbUrl = URL.createObjectURL(rec.thumb);
                div.innerHTML = `<img src="${thumbUrl}" alt="Background"><div class="layer-btn delete" title="Remove from folder">x</div>`;
                const img = div.querySelector('img');
                img.onload = () => URL.revokeObjectURL(thumbUrl);
                img.addEventListener('click', () => {
                    const fullUrl = URL.createObjectURL(rec.full);
                    const imgEl = new Image();
                    imgEl.onload = () => { setBackground(imgEl, 'image'); URL.revokeObjectURL(fullUrl); localAssetFolderOverlay.classList.remove('visible'); };
                    imgEl.onerror = () => { URL.revokeObjectURL(fullUrl); toast('Could not load background image.', 3000); };
                    imgEl.src = fullUrl;
                });
                div.querySelector('.delete').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const idNum = Number(div.dataset.assetId);
                    openConfirmationModal('Remove this background from your library?', async () => { div.remove(); await deleteAssetFromLibrary(idNum); });
                });
                localAssetGridBackgrounds.appendChild(div);
            }
        }

        function handleBackgroundUpload(file) {
            if (!file || !file.type.startsWith('image/')) { toast('Unsupported file type for background. Please use an image.'); return; }
            const reader = new FileReader();
            reader.onload = (e) => {
                const dataURL = e.target.result;
                saveAssetToLibrary({ dataURL, kind: 'background' });
                const img = new Image();
                img.onload = () => { setBackground(img); };
                img.onerror = () => toast('Could not load background image.');
                img.src = dataURL;
            };
            reader.readAsDataURL(file);
        }
        
        function processUploadedFile(file) {
            if (!file || !file.type.startsWith('image/')) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const dataURL = e.target.result;
                saveAssetToLibrary({ dataURL, kind: 'asset' });
                addImageLayer(dataURL);
                closeAssetLibrary();
            };
            reader.readAsDataURL(file);
        }
        
        async function handleNewAsset(src) {
            if (!canvasState.backgroundElement) { toast('Please set a background before adding layers.', 2000); return; }
            if (!src.startsWith('blob:')) { await saveAssetToLibrary({ dataURL: src, kind: 'asset' }); }
            addImageLayer(src);
        }
        
        function addImageLayer(src) {
            if (!canvasState.backgroundElement) { toast('Please add a background image first.', 2000); return; }
            const createFromImage = (img) => {
                const w = img.naturalWidth || 0;
                const h = img.naturalHeight || 0;
                if (!w || !h) { img.addEventListener('load', () => createFromImage(img), { once: true }); return; }
                const proxyCanvas = document.createElement('canvas');
                proxyCanvas.width = w;
                proxyCanvas.height = h;
                proxyCanvas.getContext('2d').drawImage(img, 0, 0);
                const newLayer = { id: (Date.now() + Math.random()).toString(), src, asset: img, type: 'image', x: movieCanvas.width / 2, y: movieCanvas.height / 2, size: Math.max(20, movieCanvas.width * 0.25), rot: 0, flipX: false, opacity: 1, brightness: 1, saturation: 1, shadow: { enabled: false, color: '#000000', blur: 10, offsetX: 10, offsetY: 10 }, border: { enabled: false, color: '#FFFFFF', width: 4 }, proxyCanvas, proxyCtx: proxyCanvas.getContext('2d'), undoStack: [], createdAt: Date.now() };
                canvasState.layers.unshift(newLayer);
                activeLayerId = newLayer.id;
                renderLayerPalette();
                renderTextLayerPalette();
                updateEditPanelsUI();
                triggerAnimatedRender();
            };
            if (assetCache[src]) { createFromImage(assetCache[src]); return; }
            const image = new Image();
            image.crossOrigin = 'anonymous';
            image.onload = () => { assetCache[src] = image; createFromImage(image); };
            image.onerror = () => toast(`Could not load asset: ${src}`);
            image.src = src;
        }
        
        function updateControlsState() {
            const hasBackground = !!canvasState.backgroundElement;
            downloadImageBtn.disabled = !hasBackground;
            clearCanvasBtn.disabled = !hasBackground;
            visualsBtn.disabled = !hasBackground;
            textBtn.disabled = !hasBackground;
            eraseToolBtn.disabled = !hasBackground;
            aiToolsBtn.disabled = !hasBackground;
            addNewTextLayerBtn.disabled = !hasBackground;
            renderLayerPalette();
            renderTextLayerPalette();
            updateEraseHistoryButtons();
        }

        function setBackground(element) {
            canvasState.backgroundElement = element;
            canvasState.backgroundType = 'image';
            const w = element.naturalWidth;
            const h = element.naturalHeight;
            masterWidth = w;
            masterHeight = h;
            movieCanvas.width = controlsOverlayCanvas.width = w;
            movieCanvas.height = controlsOverlayCanvas.height = h;
            resizeCanvas();
            updateControlsState();
            updateEditPanelsUI();
            let startTime = null;
            function animateBackground(currentTime) {
                if (!startTime) startTime = currentTime;
                const progress = Math.min((currentTime - startTime) / 500, 1);
                if (!canvasPlaceholder.classList.contains('hidden')) { canvasPlaceholder.classList.add('hidden'); }
                movieCtx.clearRect(0, 0, movieCanvas.width, movieCanvas.height);
                movieCtx.save();
                movieCtx.globalAlpha = progress;
                movieCtx.filter = `brightness(${canvasState.bgBrightness}) saturate(${canvasState.bgSaturation})`;
                movieCtx.drawImage(canvasState.backgroundElement, 0, 0, movieCanvas.width, movieCanvas.height);
                movieCtx.restore();
                drawLayers(movieCtx, canvasState.layers);
                drawControlsOverlay();
                if (progress < 1) { requestAnimationFrame(animateBackground); } 
                else { drawFrame(); }
            }
            requestAnimationFrame(animateBackground);
            toast('Background set! Add layers to create your image.', 3000);
        }
        
        function resizeCanvas() {
            const panelWidth = canvasPanel.clientWidth;
            const panelHeight = canvasPanel.clientHeight;
            if (panelWidth === 0 || panelHeight === 0) return;

            const canvasAspectRatio = movieCanvas.width / movieCanvas.height;
            let displayWidth, displayHeight;
            if (panelWidth / panelHeight > canvasAspectRatio) {
                displayHeight = panelHeight;
                displayWidth = displayHeight * canvasAspectRatio;
            } else {
                displayWidth = panelWidth;
                displayHeight = displayWidth / canvasAspectRatio;
            }

            const topOffset = (panelHeight - displayHeight) / 2;
            const leftOffset = (panelWidth - displayWidth) / 2;

            [movieCanvas, controlsOverlayCanvas].forEach(c => {
                c.style.width = `${displayWidth}px`;
                c.style.height = `${displayHeight}px`;
                c.style.position = 'absolute';
                c.style.top = `${topOffset}px`;
                c.style.left = `${leftOffset}px`;
            });

            pasteboardOverlayCanvas.width = movieCanvas.width + PASTEBOARD_MARGIN * 2;
            pasteboardOverlayCanvas.height = movieCanvas.height + PASTEBOARD_MARGIN * 2;

            const scaleFactor = displayWidth / movieCanvas.width;
            pasteboardOverlayCanvas.style.width = `${pasteboardOverlayCanvas.width * scaleFactor}px`;
            pasteboardOverlayCanvas.style.height = `${pasteboardOverlayCanvas.height * scaleFactor}px`;
            
            const pasteboardTopOffset = topOffset - (PASTEBOARD_MARGIN * scaleFactor);
            const pasteboardLeftOffset = leftOffset - (PASTEBOARD_MARGIN * scaleFactor);
            
            pasteboardOverlayCanvas.style.position = 'absolute';
            pasteboardOverlayCanvas.style.top = `${pasteboardTopOffset}px`;
            pasteboardOverlayCanvas.style.left = `${pasteboardLeftOffset}px`;
        }
        
        function populateAssetLibraryGrid() {
            document.getElementById('mg-asset-picker-grid').innerHTML = '';
            Array.from({ length: 104 }, (_, i) => i + 1).forEach(i => {
                const src = `./assets/maker/${i}.png`;
                const div = document.createElement('div');
                div.className = 'mg-template';
                div.innerHTML = `<img src="${src}" alt="Asset ${i}">`;
                div.addEventListener('click', () => { handleNewAsset(src); closeAssetLibrary(); });
                document.getElementById('mg-asset-picker-grid').appendChild(div);
            });
        }

        function openAssetLibrary() {
            if (!canvasState.backgroundElement) { toast('Please set a background before adding layers.', 2000); return; }
            populateAssetLibraryGrid();
            assetLibraryOverlay.classList.add('visible');
        }

        function closeAssetLibrary() { assetLibraryOverlay.classList.remove('visible'); }

        function updateLayerInstructions() {
            layerInstructions.classList.remove('placeholder-text');
            if (!canvasState.backgroundElement) { layerInstructions.textContent = "Add a background to begin."; layerInstructions.classList.add('placeholder-text'); } 
            else if (canvasState.layers.filter(l => l.type === 'image').length === 0) { layerInstructions.textContent = "Click '+' to add your first visual layer."; } 
            else { layerInstructions.textContent = "Click & drag layers to arrange and re-order them."; }
        }

        function renderTextLayerPalette() {
            textLayerPalette.innerHTML = '';
            if (!canvasState.backgroundElement) return;
            const textLayers = canvasState.layers.filter(l => l.type === 'text');
            textLayers.forEach(layer => {
                const thumb = document.createElement('div');
                thumb.className = 'layer-thumb text-thumb';
                thumb.classList.toggle('active', layer.id === activeLayerId);
                thumb.dataset.layerId = layer.id;
                thumb.title = "Click to select";
                thumb.innerHTML = `<span>${layer.text.split('\n')[0] || "Empty"}</span><div class="layer-controls"><div class="layer-btn delete" title="Delete Layer">x</div></div>`;
                thumb.addEventListener('click', (e) => {
                    if (e.target.classList.contains('layer-btn')) return;
                     if (activeLayerId !== layer.id) deactivateEraser();
                    activeLayerId = layer.id;
                    renderLayerPalette();
                    renderTextLayerPalette();
                    updateEditPanelsUI();
                    drawFrame();
                });
                thumb.querySelector('.delete').onclick = (e) => { e.stopPropagation(); deleteMovieLayer(layer.id); };
                textLayerPalette.appendChild(thumb);
            });
        }
        
        function addDragAndDropHandlers(thumb) {
            thumb.setAttribute('draggable', 'true');
            thumb.addEventListener('dragstart', (e) => { e.dataTransfer.setData('text/plain', thumb.dataset.layerId); setTimeout(() => thumb.classList.add('dragging'), 0); });
            thumb.addEventListener('dragend', () => { document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over')); thumb.classList.remove('dragging'); });
            thumb.addEventListener('dragover', (e) => { e.preventDefault(); if (document.querySelector('.dragging') !== thumb) { thumb.classList.add('drag-over'); } });
            thumb.addEventListener('dragleave', () => thumb.classList.remove('drag-over'));
            thumb.addEventListener('drop', (e) => {
                e.preventDefault();
                thumb.classList.remove('drag-over');
                const draggedId = e.dataTransfer.getData('text/plain');
                const droppedOnId = thumb.dataset.layerId;
                if (draggedId === droppedOnId) return;
                const i1 = canvasState.layers.findIndex(l => l.id.toString() === draggedId);
                const i2 = canvasState.layers.findIndex(l => l.id.toString() === droppedOnId);
                if (i1 > -1 && i2 > -1) {
                    const [item] = canvasState.layers.splice(i1, 1);
                    canvasState.layers.splice(i2, 0, item);
                    renderLayerPalette();
                    updateTextOrderButtonsState?.();
                    drawFrame();
                }
            });
        }
        
        function renderLayerPalette() {
            assetPalette.innerHTML = '';
            updateLayerInstructions();
            const hasBackground = !!canvasState.backgroundElement;
            const visualLayers = hasBackground ? canvasState.layers.filter(l => l.type === 'image') : [];
            visualLayers.forEach(layer => {
                const thumb = document.createElement('div');
                thumb.className = 'layer-thumb';
                thumb.classList.toggle('active', layer.id === activeLayerId);
                thumb.dataset.layerId = layer.id;
                let thumbSrc = '';
                try { thumbSrc = layer.proxyCanvas.toDataURL(); } catch (e) { thumbSrc = ''; }
                thumb.innerHTML = `${thumbSrc ? `<img src="${thumbSrc}">` : '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:10px;">(loading)</div>'}<div class="layer-controls"><div class="layer-btn delete" title="Delete Layer">x</div></div>`;
                addDragAndDropHandlers(thumb);
                thumb.addEventListener('click', (e) => {
                    if (e.target.classList.contains('layer-btn')) return;
                    if (activeLayerId !== layer.id) deactivateEraser();
                    activeLayerId = layer.id;
                    renderLayerPalette();
                    renderTextLayerPalette();
                    updateEditPanelsUI();
                    drawFrame();
                });
                thumb.querySelector('.delete').onclick = (e) => { e.stopPropagation(); deleteMovieLayer(layer.id); };
                assetPalette.appendChild(thumb);
            });
            const emptySlot = document.createElement('button');
            emptySlot.className = 'palette-slot empty';
            emptySlot.innerHTML = '+';
            emptySlot.title = hasBackground ? 'Add a new image asset' : 'Add a background to enable layers';
            emptySlot.disabled = !hasBackground;
            if (hasBackground) { emptySlot.onclick = openAssetLibrary; }
            assetPalette.appendChild(emptySlot);
        }
        
        function switchVisualsTab(tabToShow) {
            const isAssetTab = tabToShow === 'asset';
            visualsTabAssetBtn.classList.toggle('active', isAssetTab);
            visualsTabBackgroundBtn.classList.toggle('active', !isAssetTab);
            assetTabPanel.classList.toggle('hidden', !isAssetTab);
            backgroundTabPanel.classList.toggle('hidden', isAssetTab);
        }
        
        function updateAssetVisualsUI() {
            const activeLayer = getActiveLayer();
            if (activeLayer && activeLayer.type === 'image') {
                if (visualsDropdown.classList.contains('visible') && !visualsTabAssetBtn.classList.contains('active')) { switchVisualsTab('asset'); }
                assetVisualsControls.classList.remove('disabled');
                assetOpacitySlider.value = activeLayer.opacity;
                assetBrightnessSlider.value = activeLayer.brightness;
                assetSaturationSlider.value = activeLayer.saturation;
                document.getElementById('shadow-enable').checked = activeLayer.shadow.enabled;
                document.getElementById('shadow-controls').classList.toggle('disabled', !activeLayer.shadow.enabled);
                document.getElementById('shadow-color').value = activeLayer.shadow.color;
                document.getElementById('shadow-blur').value = activeLayer.shadow.blur;
                document.getElementById('shadow-offset-x').value = activeLayer.shadow.offsetX;
                document.getElementById('shadow-offset-y').value = activeLayer.shadow.offsetY;
                document.getElementById('asset-edge-enable').checked = activeLayer.border.enabled;
                document.getElementById('asset-edge-controls').classList.toggle('disabled', !activeLayer.border.enabled);
                document.getElementById('asset-edge-color').value = activeLayer.border.color;
                document.getElementById('asset-edge-width').value = activeLayer.border.width;
            } else {
                if (visualsDropdown.classList.contains('visible') && visualsTabAssetBtn.classList.contains('active')) { switchVisualsTab('background'); }
                assetVisualsControls.classList.add('disabled');
            }
        }
        
        function populateCustomFontSelector() {
            fontSelectList.innerHTML = '';
            availableFonts.forEach(font => {
                const li = document.createElement('li');
                li.textContent = font.name;
                li.dataset.fontValue = font.value;
                li.style.fontFamily = font.value;
                if (font.style) { li.setAttribute('style', `font-family: ${font.value}; ${font.style}`); }
                li.addEventListener('mouseenter', handleFontHoverPreview);
                li.addEventListener('click', handleFontSelect);
                fontSelectList.appendChild(li);
            });
        }

        function handleFontHoverPreview(e) {
            const activeLayer = getActiveLayer();
            if (!activeLayer || activeLayer.type !== 'text') return;
            if (originalFontOnHover === null) { originalFontOnHover = activeLayer.font; }
            activeLayer.font = e.target.dataset.fontValue;
            if (!movieInteraction.active) drawFrame();
        }

        function handleFontHoverEnd() {
            const activeLayer = getActiveLayer();
            if (originalFontOnHover && activeLayer && activeLayer.type === 'text') {
                activeLayer.font = originalFontOnHover;
                originalFontOnHover = null;
                if (!movieInteraction.active) drawFrame();
            }
        }

        function handleFontSelect(e) {
            const activeLayer = getActiveLayer();
            const newFontValue = e.target.dataset.fontValue;
            if (activeLayer && activeLayer.type === 'text') { activeLayer.font = newFontValue; }
            originalFontOnHover = null; 
            fontSelectTrigger.querySelector('span').textContent = e.target.textContent;
            fontSelectTrigger.querySelector('span').style.fontFamily = newFontValue;
            fontSelectList.querySelector('.selected')?.classList.remove('selected');
            e.target.classList.add('selected');
            closeFontDropdown();
            if (!movieInteraction.active) drawFrame();
        }

        function openFontDropdown() {
            customFontSelect.classList.add('open');
            fontSelectDropdown.classList.remove('hidden');
            originalFontOnHover = null;
        }

        function closeFontDropdown() {
            if (!customFontSelect.classList.contains('open')) return;
            handleFontHoverEnd();
            customFontSelect.classList.remove('open');
            fontSelectDropdown.classList.add('hidden');
        }

        function updateTextVisualsUI() {
            const activeLayer = getActiveLayer();
            if (activeLayer && activeLayer.type === 'text') {
                textVisualsControls.classList.remove('disabled');
                textContentInput.value = activeLayer.text;
                textSizeSlider.value = activeLayer.fontSize;
                textColorInput.value = activeLayer.color;
                textEdgeColorInput.value = activeLayer.strokeColor;
                textEdgeWidthSlider.value = activeLayer.strokeWidth;
                
                document.getElementById('text-shadow-enable').checked = activeLayer.shadow.enabled;
                document.getElementById('text-shadow-controls').classList.toggle('disabled', !activeLayer.shadow.enabled);
                document.getElementById('text-shadow-color').value = activeLayer.shadow.color;
                document.getElementById('text-shadow-blur').value = activeLayer.shadow.blur;
                document.getElementById('text-shadow-offset-x').value = activeLayer.shadow.offsetX;
                document.getElementById('text-shadow-offset-y').value = activeLayer.shadow.offsetY;

                const fontName = availableFonts.find(f => f.value === activeLayer.font)?.name || 'Select Font';
                const fontValue = activeLayer.font;
                fontSelectTrigger.querySelector('span').textContent = fontName;
                fontSelectTrigger.querySelector('span').style.fontFamily = fontValue;
                fontSelectList.querySelector('.selected')?.classList.remove('selected');
                const liToSelect = fontSelectList.querySelector(`[data-font-value="${fontValue}"]`);
                if (liToSelect) liToSelect.classList.add('selected');
            } else {
                textVisualsControls.classList.add('disabled');
            }
        }

        function updateBackgroundVisualsUI() {
            bgBrightnessSlider.value = canvasState.bgBrightness;
            bgSaturationSlider.value = canvasState.bgSaturation;
        }

        function updateEditPanelsUI() {
            updateAssetVisualsUI();
            updateTextVisualsUI();
            updateBackgroundVisualsUI();
            updateEraseHistoryButtons();
            updateTextOrderButtonsState();
        }

        function addTextLayer() {
            if (!canvasState.backgroundElement) { toast('Add a background first.', 2000); return; }
            const newTextLayer = { id: (Date.now() + Math.random()).toString(), type: 'text', text: 'New Text', font: "'VT323', monospace", fontSize: 150, color: '#FFFFFF', strokeColor: '#000000', strokeWidth: 0, x: movieCanvas.width / 2, y: movieCanvas.height / 2, rot: 0, flipX: false, opacity: 1, brightness: 1, saturation: 1, width: 0, height: 0, shadow: { enabled: false, color: '#000000', blur: 10, offsetX: 10, offsetY: 10 }, border: { enabled: false, color: '#FFFFFF', width: 4 }, createdAt: Date.now() };
            canvasState.layers.unshift(newTextLayer);
            activeLayerId = newTextLayer.id;
            deactivateEraser();
            renderLayerPalette();
            renderTextLayerPalette();
            updateControlsState();
            updateEditPanelsUI();
            triggerAnimatedRender();
            toast('Text layer added!', 2000);
            textContentInput.focus();
            textContentInput.select();
        }

        function deleteMovieLayer(layerId) {
            canvasState.layers = canvasState.layers.filter(l => l.id !== layerId);
            if (activeLayerId === layerId) { activeLayerId = null; deactivateEraser(); }
            renderLayerPalette();
            renderTextLayerPalette();
            updateControlsState();
            updateEditPanelsUI();
            drawFrame();
        }
        
        function getTextBlockMetrics(ctx, text, font, fontSize) {
            ctx.save();
            ctx.font = `${fontSize}px ${font}`;
            const lines = text.split('\n');
            const lineHeight = fontSize * 1.2;
            let maxWidth = 0;
            lines.forEach(line => { const lineWidth = ctx.measureText(line).width; if (lineWidth > maxWidth) maxWidth = lineWidth; });
            const totalHeight = lines.length * lineHeight;
            ctx.restore();
            return { lines, lineHeight, maxWidth, totalHeight };
        }
        
        function nudgeLayerZ(layerId, delta) {
            const i = canvasState.layers.findIndex(l => l.id === layerId);
            if (i === -1) return false;
            const j = i + delta;
            if (j < 0 || j >= canvasState.layers.length) return false;
            const [item] = canvasState.layers.splice(i, 1);
            canvasState.layers.splice(j, 0, item);
            return true;
        }

        function drawLayers(ctx, layers, isFinalRender = false) {
             for (let i = layers.length - 1; i >= 0; i--) {
                const l = layers[i];
                ctx.save();
                const age = Date.now() - l.createdAt;
                let animationProgress = 1;
                if (!isFinalRender && age < FADE_IN_DURATION) { animationProgress = age / FADE_IN_DURATION; }
                const filters = `brightness(${l.brightness}) saturate(${l.saturation})`;
                const shadow = l.shadow.enabled ? `drop-shadow(${l.shadow.offsetX}px ${l.shadow.offsetY}px ${l.shadow.blur}px ${l.shadow.color})` : '';
                let borderFilters = '';
                if (l.type === 'image' && l.border.enabled && l.border.width > 0) { const w = l.border.width, c = l.border.color; borderFilters = `drop-shadow(${w}px ${w}px 0 ${c}) drop-shadow(-${w}px -${w}px 0 ${c}) drop-shadow(-${w}px ${w}px 0 ${c}) drop-shadow(${w}px -${w}px 0 ${c})`; }
                ctx.filter = `${borderFilters} ${shadow} ${filters}`.trim();
                ctx.globalAlpha = l.opacity * animationProgress;
                ctx.translate(l.x, l.y);
                ctx.rotate(l.rot * Math.PI / 180);
                const scaleFactor = 0.95 + 0.05 * animationProgress;
                if (animationProgress < 1) { ctx.scale(scaleFactor, scaleFactor); }
                if (l.flipX) ctx.scale(-1, 1);
                if (l.type === 'image') {
                    const asset = l.proxyCanvas;
                    const assetWidth = asset.width;
                    const assetHeight = asset.height;
                    if (assetWidth > 0) { const dWidth = l.size; const dHeight = l.size * (assetHeight / assetWidth); ctx.drawImage(asset, -dWidth / 2, -dHeight / 2, dWidth, dHeight); }
                } else if (l.type === 'text') {
                    ctx.font = `${l.fontSize}px ${l.font}`;
                    ctx.fillStyle = l.color;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    if (l.strokeWidth > 0) { ctx.strokeStyle = l.strokeColor; ctx.lineWidth = l.strokeWidth; }
                    const metrics = getTextBlockMetrics(ctx, l.text, l.font, l.fontSize);
                    if (!isFinalRender) { l.width = metrics.maxWidth; l.height = metrics.totalHeight; }
                    const startY = -metrics.totalHeight / 2 + metrics.lineHeight / 2 - (l.fontSize * 0.1);
                    metrics.lines.forEach((line, index) => {
                        if (l.strokeWidth > 0) ctx.strokeText(line, 0, startY + (index * metrics.lineHeight));
                        ctx.fillText(line, 0, startY + (index * metrics.lineHeight));
                    });
                }
                ctx.restore();
            }
        }

        function animationRenderLoop() {
            if (!isAnimatingRender) return;
            const stillAnimating = canvasState.layers.some(l => (Date.now() - l.createdAt) < FADE_IN_DURATION);
            if (stillAnimating) { drawFrame(); requestAnimationFrame(animationRenderLoop); } 
            else { isAnimatingRender = false; if (!movieInteraction.active) { drawFrame(); } }
        }

        function triggerAnimatedRender() {
            if (isAnimatingRender || movieInteraction.active) return;
            isAnimatingRender = true;
            animationRenderLoop();
        }

        function drawFrame() {
            if (!canvasState.backgroundElement) { movieCtx.clearRect(0, 0, movieCanvas.width, movieCanvas.height); return; }
            movieCtx.clearRect(0, 0, movieCanvas.width, movieCanvas.height);
            movieCtx.save();
            movieCtx.filter = `brightness(${canvasState.bgBrightness}) saturate(${canvasState.bgSaturation})`;
            movieCtx.drawImage(canvasState.backgroundElement, 0, 0, movieCanvas.width, movieCanvas.height);
            movieCtx.restore();
            if (!isCanvasViewZoomedOut) {
                drawLayers(movieCtx, canvasState.layers);
            }
            drawControlsOverlay();
        }
        
        function startRenderLoop() { if (animationFrameId) return; function loop() { drawFrame(); animationFrameId = requestAnimationFrame(loop); } loop(); }
        function stopRenderLoop() { cancelAnimationFrame(animationFrameId); animationFrameId = null; drawFrame(); }

        function drawControlsOverlay() {
            updateSelectionBoxDOM();
        
            if (isCanvasViewZoomedOut) {
                const ctx = pasteboardCtx;
                const canvas = pasteboardOverlayCanvas;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
        
                ctx.save();
                ctx.translate(PASTEBOARD_MARGIN, PASTEBOARD_MARGIN);
                drawLayers(ctx, canvasState.layers);
                ctx.restore();
        
                if (eraserMode !== 'none' && !movieInteraction.active) {
                    const canvasPoint = getMovieCanvasPoint({clientX: eraseBrushPos.x + movieCanvas.getBoundingClientRect().left, clientY: eraseBrushPos.y + movieCanvas.getBoundingClientRect().top});
                    ctx.save();
                    ctx.translate(PASTEBOARD_MARGIN, PASTEBOARD_MARGIN);
                    const brushColor = eraserMode === 'unerase' ? 'rgba(85, 204, 85, 0.9)' : 'white';
                    ctx.beginPath();
                    ctx.arc(canvasPoint.x, canvasPoint.y, eraserSizeSlider.value / 2, 0, 2 * Math.PI);
                    ctx.strokeStyle = brushColor;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(canvasPoint.x, canvasPoint.y, eraserSizeSlider.value / 2, 0, 2 * Math.PI);
                    ctx.setLineDash([5, 5]);
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.restore();
                }
            } else {
                const ctx = controlsCtx;
                const canvas = controlsOverlayCanvas;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (eraserMode !== 'none' && !movieInteraction.active) {
                    const canvasPoint = getMovieCanvasPoint({clientX: eraseBrushPos.x + movieCanvas.getBoundingClientRect().left, clientY: eraseBrushPos.y + movieCanvas.getBoundingClientRect().top});
                    ctx.save();
                    const brushColor = eraserMode === 'unerase' ? 'rgba(85, 204, 85, 0.9)' : 'white';
                    ctx.beginPath();
                    ctx.arc(canvasPoint.x, canvasPoint.y, eraserSizeSlider.value / 2, 0, 2 * Math.PI);
                    ctx.strokeStyle = brushColor;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(canvasPoint.x, canvasPoint.y, eraserSizeSlider.value / 2, 0, 2 * Math.PI);
                    ctx.setLineDash([5, 5]);
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.restore();
                }
            }
        }
        
        function createSelectionBoxHandles(box, styleId) {
            box.innerHTML = ''; 
            const style = borderStyles.find(s => s.id === styleId);
            if (!style) return;
            ['top-left', 'top-right', 'bottom-left', 'bottom-right'].forEach(handle => { box.appendChild(Object.assign(document.createElement('div'), { className: `resizer ${handle}` })); });
            const rotater = Object.assign(document.createElement('div'), { className: 'rotater' });
            rotater.innerHTML = style.svg || '';
            box.appendChild(rotater);
        }

        function updateSelectionBoxDOM() {
            const l = getActiveLayer();
            if (!l || eraserMode !== 'none') {
                selectionBox.classList.remove('visible');
                return;
            }
            selectionBox.classList.add('visible');

            const styleClass = activeBorderStyle;
            if (!selectionBox.classList.contains(styleClass)) {
                selectionBox.className = `visible ${styleClass}`;
                createSelectionBoxHandles(selectionBox, styleClass);
            }

            const baseCanvas = isCanvasViewZoomedOut ? pasteboardOverlayCanvas : movieCanvas;
            const baseRect = baseCanvas.getBoundingClientRect();
            const panelRect = canvasPanel.getBoundingClientRect();

            const scale = baseRect.width / baseCanvas.width;

            const { dWidth, dHeight } = getLayerMetrics(l);
            if (!dWidth || !dHeight) {
                selectionBox.classList.remove('visible');
                return;
            }

            const marginScreen = isCanvasViewZoomedOut ? (PASTEBOARD_MARGIN * scale) : 0;

            const screenWidth = dWidth * scale;
            const screenHeight = dHeight * scale;

            const offsetLeft = baseRect.left - panelRect.left;
            const offsetTop = baseRect.top - panelRect.top;
            selectionBox.style.position = 'absolute';
            selectionBox.style.left = `${offsetLeft}px`;
            selectionBox.style.top = `${offsetTop}px`;
            selectionBox.style.width = `${screenWidth}px`;
            selectionBox.style.height = `${screenHeight}px`;

            const screenX = (l.x - dWidth / 2) * scale + marginScreen;
            const screenY = (l.y - dHeight / 2) * scale + marginScreen;

            selectionBox.style.transform = `translate(${screenX}px, ${screenY}px) rotate(${l.rot}deg)`;
        }

        function toggleCanvasZoom() {
            selectionBox.classList.remove('visible');
            isCanvasViewZoomedOut = !isCanvasViewZoomedOut;
            canvasPanel.classList.toggle('is-zoomed-out', isCanvasViewZoomedOut);
            toggleViewBtn.textContent = isCanvasViewZoomedOut ? '⛶' : '⬚';
            toggleViewBtn.title = isCanvasViewZoomedOut ? 'Reset Canvas View (Z)' : 'Zoom Out Canvas (Z)';
            
            movieCanvas.addEventListener('transitionend', drawFrame, { once: true });

            requestAnimationFrame(() => {
                resizeCanvas();
            });
        }

        function downloadImage() {
            if (!canvasState.backgroundElement) { toast("Add a background before downloading.", 3000); return; }
            toast("Preparing high-quality image...", null);
            requestAnimationFrame(() => {
                try {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = masterWidth;
                    tempCanvas.height = masterHeight;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.imageSmoothingEnabled = true;
                    tempCtx.imageSmoothingQuality = 'high';
                    tempCtx.save();
                    tempCtx.filter = `brightness(${canvasState.bgBrightness}) saturate(${canvasState.bgSaturation})`;
                    tempCtx.drawImage(canvasState.backgroundElement, 0, 0, masterWidth, masterHeight);
                    tempCtx.restore();
                    drawLayers(tempCtx, canvasState.layers, true);
                    const link = document.createElement('a');
                    link.download = 'image-maker-creation.png';
                    link.href = tempCanvas.toDataURL('image/png');
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    toast("Image download started!", 4000);
                } catch (error) {
                    console.error("Download failed:", error);
                    toast("Error: Could not generate image. Check console.", 5000);
                }
            }); 
        }

        function showEraserZoom(show){ eraserZoomCanvas.classList.toggle('visible', show); }
        function showEraserHUD(show){ eraserHud.classList.toggle('visible', show); }
        
        function updateEraserHudState() {
            hudEraseBtn.classList.toggle('active', eraserMode === 'erase');
            hudUneraseBtn.classList.toggle('active', eraserMode === 'unerase');
            eraserSizeMini.value = eraserSizeSlider.value;
            eraserStrengthMini.value = eraserOpacitySlider.value;
        }

        function lerp(a,b,t){ return a+(b-a)*Math.min(1,Math.max(0,t)); }
        function computeZoomUiSize(brush){ const t=(brush-BRUSH_MIN)/(BRUSH_MAX-BRUSH_MIN); return Math.round(lerp(UI_MIN_PX,UI_MAX_PX,t)); }

        function drawEraserZoomAt(canvasPoint){
          if (!canvasState.backgroundElement) return;
          const brush = Math.max(5, Number(eraserSizeSlider.value));
          const uiPx = computeZoomUiSize(brush);
          if (eraserZoomCanvas.width !== uiPx || eraserZoomCanvas.height !== uiPx){
            eraserZoomCanvas.width = uiPx; eraserZoomCanvas.height = uiPx;
            eraserZoomCanvas.style.width = uiPx + 'px'; eraserZoomCanvas.style.height = uiPx + 'px';
            eraserHud.style.bottom = (12 + uiPx + 12) + 'px';
          }
          let targetR = Math.min(TARGET_RADIUS_PX, uiPx/2 - MIN_MARGIN_PREVIEW);
          let sw = (brush * uiPx) / (2 * targetR);
          let sh = sw;
          const rect = movieCanvas.getBoundingClientRect();
          const mainScale = rect.width / movieCanvas.width;
          const factor = uiPx / sw;
          const minFactor = mainScale * MIN_ZOOM_FEEL;
          if (factor < minFactor){ sw = uiPx / minFactor; sh = sw; }
          sw = Math.min(sw, movieCanvas.width);
          sh = Math.min(sh, movieCanvas.height);
          let sx = canvasPoint.x - sw / 2;
          let sy = canvasPoint.y - sh / 2;
          sx = Math.max(0, Math.min(movieCanvas.width  - sw, sx));
          sy = Math.max(0, Math.min(movieCanvas.height - sh, sy));
          eraserZoomCtx.clearRect(0,0,uiPx,uiPx);
          eraserZoomCtx.imageSmoothingEnabled = true;
          eraserZoomCtx.imageSmoothingQuality = 'high';
          eraserZoomCtx.drawImage(movieCanvas, sx, sy, sw, sh, 0, 0, uiPx, uiPx);
          const scale = uiPx / sw;
          const rZoom = (brush / 2) * scale;
          const cx = (canvasPoint.x - sx) * scale;
          const cy = (canvasPoint.y - sy) * scale;
          eraserZoomCtx.save();
          eraserZoomCtx.beginPath();
          eraserZoomCtx.arc(cx, cy, rZoom, 0, Math.PI*2);
          eraserZoomCtx.strokeStyle = (eraserMode === 'unerase') ? 'rgba(85, 204, 85, 0.9)' : '#ffffff';
          eraserZoomCtx.lineWidth = 2;
          eraserZoomCtx.stroke();
          eraserZoomCtx.setLineDash([5,5]);
          eraserZoomCtx.strokeStyle = '#000000';
          eraserZoomCtx.lineWidth = 1;
          eraserZoomCtx.beginPath();
          eraserZoomCtx.arc(cx, cy, rZoom, 0, Math.PI*2);
          eraserZoomCtx.stroke();
          eraserZoomCtx.restore();
        }

        function getMovieCanvasPoint(e) {
            if (isCanvasViewZoomedOut) {
                const pbRect = pasteboardOverlayCanvas.getBoundingClientRect();
                const scale = pbRect.width / pasteboardOverlayCanvas.width;
                const xInPb = (e.clientX - pbRect.left) / scale;
                const yInPb = (e.clientY - pbRect.top) / scale;
                const x = xInPb - PASTEBOARD_MARGIN;
                const y = yInPb - PASTEBOARD_MARGIN;
                return { x, y }; // Return unclamped coordinates
            } else {
                const movieRect = movieCanvas.getBoundingClientRect();
                const scaleX = movieCanvas.width / movieRect.width;
                const scaleY = movieCanvas.height / movieRect.height;
                return {
                    x: (e.clientX - movieRect.left) * scaleX,
                    y: (e.clientY - movieRect.top) * scaleY
                };
            }
        }
        
        function applyBrushToLayer(layer, canvasPoint) {
            if (!layer || layer.type !== 'image' || !layer.proxyCtx) return;
            const dx = canvasPoint.x - layer.x;
            const dy = canvasPoint.y - layer.y;
            const angle = -layer.rot * Math.PI / 180;
            const localX = dx * Math.cos(angle) - dy * Math.sin(angle);
            const localY = dx * Math.sin(angle) + dy * Math.cos(angle);
            const assetWidth = layer.proxyCanvas.width;
            const assetHeight = layer.proxyCanvas.height;
            const layerRenderWidth = layer.size;
            const layerRenderHeight = layer.size * (assetHeight / assetWidth);
            const proxyX = (localX + layerRenderWidth / 2) * (assetWidth / layerRenderWidth);
            const proxyY = (localY + layerRenderHeight / 2) * (assetHeight / layerRenderHeight);
            const brushSize = eraserSizeSlider.value * (assetWidth / layerRenderWidth);
            const ctx = layer.proxyCtx;
            ctx.save();
            if (eraserMode === 'unerase') {
                ctx.beginPath();
                if (movieInteraction.lastProxyX !== null && movieInteraction.lastProxyY !== null) {
                    const last = { x: movieInteraction.lastProxyX, y: movieInteraction.lastProxyY };
                    const current = { x: proxyX, y: proxyY };
                    const dist = Math.hypot(current.x - last.x, current.y - last.y);
                    const angle = Math.atan2(current.y - last.y, current.x - last.x);
                    const step = Math.min(brushSize / 4, 10);
                    for (let i = 0; i < dist; i += step) { const x = last.x + Math.cos(angle) * i; const y = last.y + Math.sin(angle) * i; ctx.moveTo(x, y); ctx.arc(x, y, brushSize / 2, 0, Math.PI * 2); }
                } else { ctx.arc(proxyX, proxyY, brushSize / 2, 0, 2 * Math.PI); }
                ctx.clip();
                ctx.globalAlpha = eraserOpacitySlider.value;
                ctx.drawImage(layer.asset, 0, 0);
            } else {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = brushSize;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.globalAlpha = eraserOpacitySlider.value;
                ctx.beginPath();
                if (movieInteraction.lastProxyX !== null && movieInteraction.lastProxyY !== null) { ctx.moveTo(movieInteraction.lastProxyX, movieInteraction.lastProxyY); ctx.lineTo(proxyX, proxyY); ctx.stroke(); } 
                else { ctx.arc(proxyX, proxyY, brushSize / 2, 0, 2 * Math.PI); ctx.fill(); }
            }
            movieInteraction.lastProxyX = proxyX;
            movieInteraction.lastProxyY = proxyY;
            ctx.restore();
            drawFrame();
            lastEraseCanvasPoint = canvasPoint;
            if (movieInteraction.active && movieInteraction.type === 'erase') { drawEraserZoomAt(canvasPoint); }
        }

        function resetErasing() {
            const layer = getActiveLayer();
            if (layer && layer.type === 'image') {
                layer.proxyCtx.clearRect(0, 0, layer.proxyCanvas.width, layer.proxyCanvas.height);
                layer.proxyCtx.drawImage(layer.asset, 0, 0);
                layer.undoStack = [];
                updateEraseHistoryButtons();
                drawFrame();
                renderLayerPalette();
                toast('Layer reset to original!', 2000);
            }
        }

        function updateEraseHistoryButtons() {
            const layer = getActiveLayer();
            if (layer && layer.type === 'image') { undoEraseBtn.disabled = layer.undoStack.length === 0; } 
            else { undoEraseBtn.disabled = true; }
        }

        function undoErasing() {
            const layer = getActiveLayer();
            if (!layer || layer.type !== 'image' || layer.undoStack.length === 0) return;
            const undoData = layer.undoStack.pop();
            layer.proxyCtx.putImageData(undoData, 0, 0);
            updateEraseHistoryButtons();
            drawFrame();
            renderLayerPalette();
        }
        
        function handleMovieInteractionStart(e) {
            e.preventDefault();
            const target = e.target;
            const point = getMovieCanvasPoint(e);
            if (isEraserArmed) { isEraserArmed = false; hideToast(); }
            if (eraserMode !== 'none') {
                const activeLayer = getActiveLayer();
                if (isPointInMovieLayer(point, activeLayer)) {
                     movieInteraction = { active: true, type: 'erase', layerId: activeLayer.id, lastProxyX: null, lastProxyY: null };
                     if(activeLayer.undoStack.length >= MAX_UNDO_STACK) { activeLayer.undoStack.shift(); }
                     activeLayer.undoStack.push(activeLayer.proxyCtx.getImageData(0, 0, activeLayer.proxyCanvas.width, activeLayer.proxyCanvas.height));
                     updateEraseHistoryButtons();
                     lastEraseCanvasPoint = point;
                     showEraserZoom(true);
                     showEraserHUD(false);
                     drawEraserZoomAt(point);
                     applyBrushToLayer(activeLayer, point);
                } else { deactivateEraser(); }
                return;
            }
            let interactionFound = false;
            const activeLayer = getActiveLayer();
            const handle = getHandleFromTarget(target);
            if (activeLayer && handle) {
                interactionFound = true;
                movieInteraction = { active: true, type: handle.type, layerId: activeLayer.id, handle: handle.pos, startX: point.x, startY: point.y, initialState: JSON.parse(JSON.stringify(activeLayer)), };
                 const metrics = getLayerMetrics(activeLayer);
                 movieInteraction.initialState.width = metrics.dWidth;
                 movieInteraction.initialState.height = metrics.dHeight;
            } else if (isPointInMovieLayer(point, activeLayer)) {
                interactionFound = true;
                movieInteraction = { active: true, type: 'drag', layerId: activeLayer.id, offsetX: point.x - activeLayer.x, offsetY: point.y - activeLayer.y, };
            }
            if (!interactionFound) {
                for (let i = 0; i < canvasState.layers.length; i++) {
                    const l = canvasState.layers[i];
                    if (isPointInMovieLayer(point, l)) {
                        activeLayerId = l.id;
                        renderLayerPalette(); renderTextLayerPalette(); updateEditPanelsUI();
                        movieInteraction = { active: true, type: 'drag', layerId: l.id, offsetX: point.x - l.x, offsetY: point.y - l.y };
                        interactionFound = true;
                        break;
                    }
                }
            }
            if (!interactionFound && activeLayerId && (target === movieCanvas || target === pasteboardOverlayCanvas) ) {
                activeLayerId = null;
                updateEditPanelsUI();
                renderLayerPalette();
                renderTextLayerPalette();
                drawFrame();
            }
            if(interactionFound) startRenderLoop();
        }

        function getHandleFromTarget(target) {
            const rotator = target.closest('.rotater');
            if (rotator) return { type: 'rotate' };
            const resizer = target.closest('.resizer');
            if (resizer) { const pos = Array.from(resizer.classList).find(c => c.includes('-')); return { type: 'resize', pos: pos }; }
            return null;
        }

        function getLayerMetrics(layer) {
            if (!layer) return { dWidth: 0, dHeight: 0 };
            let dWidth, dHeight;
             if (layer.type === 'image') {
                const assetWidth  = layer.proxyCanvas?.width  || layer.asset?.naturalWidth  || 0;
                const assetHeight = layer.proxyCanvas?.height || layer.asset?.naturalHeight || 0;
                if (!assetWidth || !assetHeight) return { dWidth: 0, dHeight: 0 };
                dWidth = layer.size;
                dHeight = layer.size * (assetHeight / assetWidth);
            } else { dWidth = layer.width; dHeight = layer.height; }
            return { dWidth, dHeight };
        }

        function isPointInMovieLayer(point, layer) {
            if (!layer) return false;
            const metrics = getLayerMetrics(layer);
            const dWidth = metrics.dWidth, dHeight = metrics.dHeight;
            const dx = point.x - layer.x;
            const dy = point.y - layer.y;
            const angle = -layer.rot * Math.PI / 180;
            const localX = dx * Math.cos(angle) - dy * Math.sin(angle);
            const localY = dx * Math.sin(angle) + dy * Math.cos(angle);
            return (Math.abs(localX) < dWidth / 2 && Math.abs(localY) < dHeight / 2);
        }

        function handleMovieInteractionMove(e) {
            const point = getMovieCanvasPoint(e);
            eraseBrushPos = { x: e.clientX - movieCanvas.getBoundingClientRect().left, y: e.clientY - movieCanvas.getBoundingClientRect().top };
            if (!movieInteraction.active) { updateCursor(e); if(eraserMode !== 'none') { drawControlsOverlay(); } return; }
            e.preventDefault();
            const l = getActiveLayer();
            if (!l) return;
            if (movieInteraction.type === 'erase') { applyBrushToLayer(l, point); drawEraserZoomAt(point); return; }
            if (movieInteraction.type === 'drag') { l.x = point.x - movieInteraction.offsetX; l.y = point.y - movieInteraction.offsetY; } 
            else if (movieInteraction.type === 'rotate') {
                const iState = movieInteraction.initialState;
                const initialAngle = Math.atan2(movieInteraction.startY - iState.y, movieInteraction.startX - iState.x) * 180 / Math.PI;
                const currentAngle = Math.atan2(point.y - iState.y, point.x - iState.x) * 180 / Math.PI;
                l.rot = iState.rot + (currentAngle - initialAngle);
            } else if (movieInteraction.type === 'resize') {
                const iState = movieInteraction.initialState;
                const initialDist = Math.hypot(movieInteraction.startX - iState.x, movieInteraction.startY - iState.y);
                const currentDist = Math.hypot(point.x - iState.x, point.y - iState.y);
                if (initialDist > 1) {
                    const scaleFactor = currentDist / initialDist;
                    if (l.type === 'text') { l.fontSize = Math.max(10, iState.fontSize * scaleFactor); textSizeSlider.value = l.fontSize; } 
                    else { l.size = Math.max(20, iState.size * scaleFactor); }
                }
            }
        }

        function handleMovieInteractionEnd(e) {
          if (movieInteraction.active) {
            const wasErasing = movieInteraction.type === 'erase';
            movieInteraction.active = false;
            showEraserZoom(false);
            if (wasErasing) { renderLayerPalette(); updateEraseHistoryButtons(); showEraserHUD(true); }
            stopRenderLoop();
          }
        }

        function updateCursor(e) {
            if (eraserMode !== 'none') {
                movieCanvas.style.cursor = 'none';
                pasteboardOverlayCanvas.style.cursor = 'none';
                return;
            }
            movieCanvas.style.cursor = '';
            pasteboardOverlayCanvas.style.cursor = '';

            const point = getMovieCanvasPoint(e);
            let newCursor = 'default';
            for (let i = 0; i < canvasState.layers.length; i++) {
                if (isPointInMovieLayer(point, canvasState.layers[i])) {
                    newCursor = (canvasState.layers[i].id === activeLayerId) ? 'move' : 'pointer';
                    break;
                }
            }
            
            if (isCanvasViewZoomedOut) {
                pasteboardOverlayCanvas.style.cursor = newCursor;
            } else {
                movieCanvas.style.cursor = newCursor;
            }
        }

        function handleKeyDown(e) {
            const key = e.key.toLowerCase();
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') { if (key === 'escape') document.activeElement.blur(); return; }
            if (key === 'z') { e.preventDefault(); toggleCanvasZoom(); return; }
            if (key === 'escape' && eraserMode !== 'none') { e.preventDefault(); deactivateEraser(); return; }
            const activeLayer = getActiveLayer();
            if (!activeLayer) return;
            if (key === 'q' || key === 'w') {
                e.preventDefault();
                const moved = nudgeLayerZ(activeLayer.id, key === 'q' ? -1 : +1);
                if (moved) { renderLayerPalette(); renderTextLayerPalette(); updateTextOrderButtonsState?.(); drawFrame(); }
                return;
            }
            if (key === 's') { e.preventDefault(); activeLayer.flipX = !activeLayer.flipX; } 
            else if (key === 'delete' || key === 'backspace') { e.preventDefault(); deleteMovieLayer(activeLayer.id); toast('Layer deleted', 2000); }
            drawFrame();
        }

        function clearCanvas() {
            canvasState = { backgroundElement: null, backgroundType: 'none', bgBrightness: 1, bgSaturation: 1, layers: [] };
            activeLayerId = null;
            deactivateEraser();
            movieCtx.clearRect(0, 0, movieCanvas.width, movieCanvas.height);
            controlsCtx.clearRect(0, 0, controlsOverlayCanvas.width, controlsOverlayCanvas.height);
            canvasPlaceholder.classList.remove('hidden');
            updateControlsState();
            updateEditPanelsUI();
            drawFrame();
            toast("Canvas cleared.", 2000);
        }

        function deactivateEraser(shouldCloseDropdown = false) {
            if (eraserMode === 'none') return;
            showEraserHUD(false);
            showEraserZoom(false);
            eraserMode = 'none';
            isEraserArmed = false;
            eraserControlsWrapper.classList.add('disabled');
            eraseBtn.classList.remove('active');
            uneraseBtn.classList.remove('active');
            eraseToolBtn.classList.remove('active');
            movieCanvas.style.cursor = '';
            pasteboardOverlayCanvas.style.cursor = '';
            hideToast();
            drawFrame();
            if (shouldCloseDropdown) { eraseToolDropdown.classList.remove('visible'); }
        }

        function toggleDropdownEraserMode(mode) {
            const activeLayer = getActiveLayer();
            if (!activeLayer) { toast('Select an image layer to use the eraser.', 3000); return; }
             if (activeLayer.type !== 'image') { toast('Eraser only works on image layers.', 3000); return; }
            if (eraserMode === mode) { deactivateEraser(false); } 
            else {
                eraserMode = mode;
                isEraserArmed = false;
                eraserControlsWrapper.classList.remove('disabled');
                eraseBtn.classList.toggle('active', mode === 'erase');
                uneraseBtn.classList.toggle('active', mode === 'unerase');
                eraseToolBtn.classList.add('active');
                 [visualsDropdown, textDropdown, shortcutsDropdown, aiToolsDropdown].forEach(d => d.classList.remove('visible'));
            }
        }
        
        function armEraserFromHUD(mode) {
             if (eraserMode !== mode) { eraserMode = mode; updateEraserHudState(); }
             isEraserArmed = true;
             toast(`${eraserMode === 'erase' ? 'Erase' : 'Unerase'} Mode Activated`, 1500);
        }

        let confirmCallback = null;
        function openConfirmationModal(text, onConfirm) { confirmationText.textContent = text; confirmCallback = onConfirm; confirmationOverlay.classList.add('visible'); }
        function closeConfirmationModal() { confirmationOverlay.classList.remove('visible'); confirmCallback = null; }

        function updateTextOrderButtonsState() {
            const textMoveBackBtn = document.getElementById('text-move-back');
            const textMoveForwardBtn = document.getElementById('text-move-forward');
            if (!textMoveBackBtn || !textMoveForwardBtn) return;
            const l = getActiveLayer();
            if (!l || l.type !== 'text') { textMoveBackBtn.disabled = true; textMoveForwardBtn.disabled = true; return; }
            const idx = canvasState.layers.findIndex(x => x.id === l.id);
            textMoveForwardBtn.disabled = (idx === 0);
            textMoveBackBtn.disabled = (idx === canvasState.layers.length - 1);
        }
        
        // ---- BG remover model sources ----
        const BG_MODELS = {
            fast: './u2netp.onnx',
            portrait: 'https://huggingface.co/smallpp/u2net-human-seg/resolve/main/u2net_human_seg.onnx',
        };

        const bgSessionCache = new Map();

        async function getBgSession(mode) {
            if (bgSessionCache.has(mode)) return bgSessionCache.get(mode);

            const url = BG_MODELS[mode] || BG_MODELS.fast;
            const modelName = mode.charAt(0).toUpperCase() + mode.slice(1);
            toast(`Loading ${modelName} model`, null);

            try {
                const resp = await fetch(url, { mode: 'cors', cache: 'force-cache' });
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                const bytes = await resp.arrayBuffer();
                
                const session = await ort.InferenceSession.create(bytes, {
                    executionProviders: ['wasm'],
                    graphOptimizationLevel: 'all',
                });

                bgSessionCache.set(mode, session);
                hideToast();
                return session;

            } catch (e) {
                hideToast();
                toast(`Couldn’t load ${mode} model. Falling back to Fast.`, 4000);
                console.error(`Failed to load '${mode}' model from ${url}. Error: ${e.message}`);
                
                if (mode !== 'fast') {
                    const picker = document.getElementById('ai-model-trigger')?.querySelector('span');
                    if(picker) picker.textContent = "Fast (General)";
                    localStorage.setItem('bgModel', 'fast');
                    return await getBgSession('fast');
                } else {
                    toast('Critical: Fast model failed to load.', 5000);
                    throw new Error("Could not load the local fallback model.");
                }
            }
        }

        function rgbaToCHWFloat32(imgData, size = 320) {
            const { data } = imgData;
            const chw = new Float32Array(3 * size * size);
            let p = 0, rOff = 0, gOff = size * size, bOff = 2 * size * size;
            for (let i = 0; i < data.length; i += 4) {
                chw[rOff + p] = data[i] / 255;
                chw[gOff + p] = data[i + 1] / 255;
                chw[bOff + p] = data[i + 2] / 255;
                p++;
            }
            return chw;
        }

        function letterboxToSquareBitmap(imgBitmap, size = 320) {
            const canvas = new OffscreenCanvas(size, size);
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            const scale = Math.min(size / imgBitmap.width, size / imgBitmap.height);
            const dw = Math.round(imgBitmap.width * scale);
            const dh = Math.round(imgBitmap.height * scale);
            const dx = Math.floor((size - dw) / 2);
            const dy = Math.floor((size - dh) / 2);
            ctx.clearRect(0, 0, size, size);
            ctx.drawImage(imgBitmap, 0, 0, imgBitmap.width, imgBitmap.height, dx, dy, dw, dh);
            return { canvas, dx, dy, dw, dh };
        }
        
        async function runU2NetOnImageLayer(layer, session, mode = 'fast') {
            // (1) give Portrait more pixels
            const side = (mode === 'portrait') ? 512 : 320;

            const bmp = await createImageBitmap(layer.asset);
            const boxed = letterboxToSquareBitmap(bmp, side);

            const pctx = boxed.canvas.getContext('2d', { willReadFrequently: true });
            const imgData = pctx.getImageData(0, 0, side, side);
            const chw = rgbaToCHWFloat32(imgData, side);
            const input = new ort.Tensor('float32', chw, [1, 3, side, side]);

            const feeds = { [session.inputNames[0]]: input };
            const results = await session.run(feeds);
            const out = results[session.outputNames[0]].data;

            // Build an alpha mask
            const maskCanvas = new OffscreenCanvas(side, side);
            const mctx = maskCanvas.getContext('2d');
            const mImg = mctx.createImageData(side, side);

            for (let i = 0; i < out.length; i++) {
                // (2) if outputs are logits, map to probabilities; otherwise keep as-is
                const v = out[i];
                const prob = (v < 0 || v > 1) ? 1 / (1 + Math.exp(-v)) : v;
                const a = Math.max(0, Math.min(1, prob));

                const j = i * 4;
                mImg.data[j] = mImg.data[j + 1] = mImg.data[j + 2] = 255;
                mImg.data[j + 3] = Math.round(a * 255);
            }
            mctx.putImageData(mImg, 0, 0);

            // (3) keep edges crisper for Portrait
            featherMask(maskCanvas, mode === 'portrait' ? 0.4 : 1.2);

            const maskBitmap = await createImageBitmap(maskCanvas);

            // Apply mask at full layer resolution
            const proxy = layer.proxyCanvas;
            const ctx = layer.proxyCtx;
            ctx.clearRect(0, 0, proxy.width, proxy.height);
            ctx.drawImage(layer.asset, 0, 0);

            const maskFull = upscaleMaskToLayer(maskBitmap, boxed, proxy.width, proxy.height);
            ctx.save();
            ctx.globalCompositeOperation = 'destination-in';
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(maskFull, 0, 0);
            ctx.restore();
        }

        async function removeBgForActiveImageLayer() {
            if (aiToolsDropdown) aiToolsDropdown.classList.remove('visible');
            
            const active = getActiveLayer();
            if (!active || active.type !== 'image') {
                toast('Select an image layer first.', 2500);
                return;
            }

            const mode = localStorage.getItem('bgModel') || 'fast';

            try {
                const session = await getBgSession(mode);
                if (!session) return; 

                toast(`Removing background`, null);
                await new Promise(resolve => setTimeout(resolve, 50));

                await runU2NetOnImageLayer(active, session, mode);
                
                toast(`Background removed.`, 2500);
                renderLayerPalette?.();
                drawFrame?.();
                updateEraseHistoryButtons?.();
            } catch (err) {
                console.error(err);
                hideToast();
                toast('BG removal failed. See console.', 4000);
            }
        }
        
        function upscaleMaskToLayer(maskBitmap, boxed, layerWidth, layerHeight) {
            const { dx, dy, dw, dh } = boxed;
            const tempMaskCanvas = new OffscreenCanvas(maskBitmap.width, maskBitmap.height);
            tempMaskCanvas.getContext('2d').drawImage(maskBitmap, 0, 0);
            const croppedMaskCanvas = new OffscreenCanvas(dw, dh);
            croppedMaskCanvas.getContext('2d').drawImage(tempMaskCanvas, dx, dy, dw, dh, 0, 0, dw, dh);
            const finalMaskCanvas = new OffscreenCanvas(layerWidth, layerHeight);
            const finalCtx = finalMaskCanvas.getContext('2d');
            finalCtx.imageSmoothingEnabled = true;
            finalCtx.imageSmoothingQuality = 'high';
            finalCtx.drawImage(croppedMaskCanvas, 0, 0, dw, dh, 0, 0, layerWidth, layerHeight);
            return finalMaskCanvas;
        }

        function featherMask(canvas, amount = 1.2) {
            const ctx = canvas.getContext('2d');
            if (amount > 0) {
                ctx.filter = `blur(${amount}px)`;
                ctx.drawImage(canvas, 0, 0);
                ctx.filter = 'none';
            }
        }

        (function addBgUI() {
            const panel = document.getElementById('ai-tools-dropdown');
            if (!panel) return;
            
            panel.innerHTML = `<h5>AI Tools</h5><h6 style="text-align: center; margin-bottom: 0.8rem; font-weight: normal;">Select a model below</h6>`;

            const customSelect = document.createElement('div');
            customSelect.id = 'ai-model-select';
            
            const trigger = document.createElement('div');
            trigger.id = 'ai-model-trigger';
            trigger.tabIndex = 0;
            trigger.innerHTML = `<span></span> <i class="fas fa-chevron-down"></i>`;

            const dropdown = document.createElement('div');
            dropdown.id = 'ai-model-dropdown';
            dropdown.classList.add('hidden');

            const list = document.createElement('ul');
            list.id = 'ai-model-list';
            list.innerHTML = `
                <li data-value="fast">Fast (General)</li>
                <li data-value="portrait">Portrait (Detailed)</li>
            `;

            dropdown.appendChild(list);
            customSelect.appendChild(trigger);
            customSelect.appendChild(dropdown);

            const btn = document.createElement('button');
            btn.className = 'mg-btn';
            btn.textContent = 'Remove Background';
            btn.style.marginTop = '0.5rem';
            btn.addEventListener('click', removeBgForActiveImageLayer);
            
            panel.appendChild(customSelect);
            panel.appendChild(btn);

            const triggerText = trigger.querySelector('span');
            
            function updateUIText(mode) {
                const text = mode === 'fast' ? 'Fast (General)' : 'Portrait (Detailed)';
                triggerText.textContent = text;
                list.querySelector('.selected')?.classList.remove('selected');
                const liToSelect = list.querySelector(`[data-value="${mode}"]`);
                if (liToSelect) liToSelect.classList.add('selected');
            }

            updateUIText(localStorage.getItem('bgModel') || 'fast');

            trigger.addEventListener('click', (e) => {
                e.stopPropagation();
                customSelect.classList.toggle('open');
                dropdown.classList.toggle('hidden');
            });

            list.querySelectorAll('li').forEach(li => {
                li.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const newMode = e.currentTarget.dataset.value;
                    localStorage.setItem('bgModel', newMode);
                    updateUIText(newMode);
                    customSelect.classList.remove('open');
                    dropdown.classList.add('hidden');
                    toast(`Switched to ${newMode === 'fast' ? 'Fast' : 'Portrait'} model`, 1600);
                });
            });
        })();

        const setupEventListeners = () => {
            const versionLink = document.getElementById('version-link');
            const versionPopupOverlay = document.getElementById('version-popup-overlay');
            const closeButton = document.getElementById('close-popup');
            versionLink.addEventListener('click', (e) => { e.preventDefault(); versionPopupOverlay.style.display = 'flex'; });
            closeButton.addEventListener('click', () => { versionPopupOverlay.style.display = 'none'; });
            versionPopupOverlay.addEventListener('click', (e) => { if (e.target === versionPopupOverlay) versionPopupOverlay.style.display = 'none'; });
            themeSelectLink.addEventListener('click', (e) => { e.preventDefault(); themeChosen = false; themePopupOverlay.style.display = 'flex'; });
            themePopupContent.addEventListener('mouseleave', () => { if (!themeChosen) applyTheme(originalTheme, true); });
            themePopupOverlay.addEventListener('click', (e) => { if (e.target === themePopupOverlay) { if (!themeChosen) applyTheme(originalTheme); themePopupOverlay.style.display = 'none'; } });
            borderStyleLink.addEventListener('click', e => { e.preventDefault(); borderStylePopup.style.display = 'flex'; });
            borderStylePopup.addEventListener('click', e => { if (e.target === borderStylePopup) borderStylePopup.style.display = 'none'; });
            initialBackgroundInput.addEventListener('change', e => { handleBackgroundUpload(e.target.files[0]); e.target.value = null; });
            downloadImageBtn.addEventListener('click', downloadImage);
            clearCanvasBtn.addEventListener('click', () => openConfirmationModal("This will clear the entire canvas. Are you sure?", () => { clearCanvas(); closeConfirmationModal(); }));
            document.getElementById('mg-asset-library-close').addEventListener('click', closeAssetLibrary);
            assetLibraryOverlay.addEventListener('click', e => { if (e.target === assetLibraryOverlay) closeAssetLibrary() });
            assetPickerFileInput.addEventListener('change', e => { processUploadedFile(e.target.files?.[0]); e.target.value = null; });
            textBtn.addEventListener('click', e => { loadSecondaryFonts(); e.stopPropagation(); deactivateEraser(true); textDropdown.classList.toggle('visible'); visualsDropdown.classList.remove('visible'); shortcutsDropdown.classList.remove('visible'); eraseToolDropdown.classList.remove('visible'); aiToolsDropdown.classList.remove('visible'); closeFontDropdown(); });
            aiToolsBtn.addEventListener('click', e => { e.stopPropagation(); deactivateEraser(true); aiToolsDropdown.classList.toggle('visible'); visualsDropdown.classList.remove('visible'); shortcutsDropdown.classList.remove('visible'); eraseToolDropdown.classList.remove('visible'); textDropdown.classList.remove('visible'); closeFontDropdown(); });
            addNewTextLayerBtn.addEventListener('click', addTextLayer);
            confirmYesBtn.addEventListener('click', async (e) => { e.stopPropagation(); const fn = confirmCallback; confirmCallback = null; try { if (typeof fn === 'function') await fn(); } catch (err) { console.error('Confirmation action failed:', err); toast('Error: Could not complete the action.', 4000); } finally { closeConfirmationModal(); } });
            confirmNoBtn.addEventListener('click', (e) => { e.stopPropagation(); closeConfirmationModal(); });
            confirmationOverlay.addEventListener('click', (e) => { if (e.target === confirmationOverlay) closeConfirmationModal(); });
            canvasPanel.addEventListener('mousedown', handleMovieInteractionStart);
            window.addEventListener('mousemove', handleMovieInteractionMove);
            window.addEventListener('mouseup', handleMovieInteractionEnd);
            canvasPanel.addEventListener('mouseleave', () => { if (!movieInteraction.active) { movieCanvas.style.cursor = 'default'; pasteboardOverlayCanvas.style.cursor = 'default'; } eraseBrushPos = {x: -1000, y: -1000}; if(eraserMode !== 'none' && !movieInteraction.active) drawControlsOverlay(); });
            window.addEventListener('keydown', handleKeyDown);
            canvasPlaceholder.addEventListener('click', () => initialBackgroundInput.click());
            canvasPanel.addEventListener('dragover', e => { e.preventDefault(); canvasPanel.classList.add('drag-over') });
            canvasPanel.addEventListener('dragleave', () => canvasPanel.classList.remove('drag-over'));
            canvasPanel.addEventListener('drop', e => { e.preventDefault(); canvasPanel.classList.remove('drag-over'); const file = e.dataTransfer.files[0]; if (file) { if (!canvasState.backgroundElement) handleBackgroundUpload(file); else processUploadedFile(file); } });
            window.addEventListener('paste', e => { if (!canvasState.backgroundElement) { const items = e.clipboardData?.items; if (!items) return; for (let i = 0; i < items.length; i++) { if (items[i].type.indexOf('image') !== -1) { const file = items[i].getAsFile(); if (file) { e.preventDefault(); handleBackgroundUpload(file); break; } } } } });
            shortcutsBtn.addEventListener('click', e => { e.stopPropagation(); deactivateEraser(true); shortcutsDropdown.classList.toggle('visible'); visualsDropdown.classList.remove('visible'); textDropdown.classList.remove('visible'); eraseToolDropdown.classList.remove('visible'); aiToolsDropdown.classList.remove('visible'); closeFontDropdown();});
            visualsBtn.addEventListener('click', e => { e.stopPropagation(); deactivateEraser(true); visualsDropdown.classList.toggle('visible'); if (visualsDropdown.classList.contains('visible')) { if (getActiveLayer() && getActiveLayer().type === 'image') { switchVisualsTab('asset'); } else { switchVisualsTab('background'); } } shortcutsDropdown.classList.remove('visible'); textDropdown.classList.remove('visible'); eraseToolDropdown.classList.remove('visible'); aiToolsDropdown.classList.remove('visible'); closeFontDropdown(); });
            visualsTabAssetBtn.addEventListener('click', () => { switchVisualsTab('asset'); if (!getActiveLayer() || getActiveLayer().type !== 'image') { toast('Select an image layer to enable asset editing.', 3000); } });
            visualsTabBackgroundBtn.addEventListener('click', () => switchVisualsTab('background'));
            eraseToolBtn.addEventListener('click', e => { e.stopPropagation(); eraseToolDropdown.classList.toggle('visible'); shortcutsDropdown.classList.remove('visible'); visualsDropdown.classList.remove('visible'); textDropdown.classList.remove('visible'); aiToolsDropdown.classList.remove('visible'); closeFontDropdown();});
            fontSelectTrigger.addEventListener('click', (e) => { e.stopPropagation(); if (customFontSelect.classList.contains('open')) { closeFontDropdown(); } else { openFontDropdown(); } });
            fontSelectDropdown.addEventListener('mouseleave', handleFontHoverEnd);
            eraseBtn.addEventListener('click', () => toggleDropdownEraserMode('erase'));
            uneraseBtn.addEventListener('click', () => toggleDropdownEraserMode('unerase'));
            hudEraseBtn.addEventListener('click', () => armEraserFromHUD('erase'));
            hudUneraseBtn.addEventListener('click', () => armEraserFromHUD('unerase'));
            eraserHud.addEventListener('mousedown', e => e.stopPropagation());
            revertErasingBtn.addEventListener('click', resetErasing);
            undoEraseBtn.addEventListener('click', undoErasing);
            [visualsDropdown, textDropdown, shortcutsDropdown, eraseToolDropdown, aiToolsDropdown].forEach(el => el.addEventListener('click', e => e.stopPropagation()));
            document.querySelectorAll('#visuals-dropdown input, #visuals-dropdown select, #text-dropdown input, #text-dropdown textarea, #erase-tool-dropdown input').forEach(input => {
                const eventType = ['range', 'color'].includes(input.type) || input.tagName === 'TEXTAREA' ? 'input' : 'change';
                input.addEventListener(eventType, () => {
                    const l = getActiveLayer();
                    if (!l && !input.id.startsWith('bg-')) return;
                    switch(input.id) {
                        case 'asset-opacity': l.opacity = parseFloat(input.value); break;
                        case 'asset-brightness': l.brightness = parseFloat(input.value); break;
                        case 'asset-saturation': l.saturation = parseFloat(input.value); break;
                        case 'bg-brightness': canvasState.bgBrightness = parseFloat(input.value); break;
                        case 'bg-saturation': canvasState.bgSaturation = parseFloat(input.value); break;
                        case 'text-content': if(l.type==='text') l.text = input.value; renderTextLayerPalette(); break;
                        case 'text-size': if(l.type==='text') l.fontSize = parseFloat(input.value); break;
                        case 'text-color': if(l.type==='text') l.color = input.value; break;
                        case 'text-edge-color': if(l.type==='text') l.strokeColor = input.value; break;
                        case 'text-edge-width': if(l.type==='text') l.strokeWidth = parseInt(input.value, 10); break;
                        case 'shadow-enable': l.shadow.enabled = input.checked; document.getElementById('shadow-controls').classList.toggle('disabled', !input.checked); break;
                        case 'shadow-color': l.shadow.color = input.value; break;
                        case 'shadow-blur': l.shadow.blur = input.value; break;
                        case 'shadow-offset-x': l.shadow.offsetX = input.value; break;
                        case 'shadow-offset-y': l.shadow.offsetY = input.value; break;
                        case 'text-shadow-enable': if(l.type==='text') { l.shadow.enabled = input.checked; document.getElementById('text-shadow-controls').classList.toggle('disabled', !input.checked); } break;
                        case 'text-shadow-color': if(l.type==='text') l.shadow.color = input.value; break;
                        case 'text-shadow-blur': if(l.type==='text') l.shadow.blur = input.value; break;
                        case 'text-shadow-offset-x': if(l.type==='text') l.shadow.offsetX = input.value; break;
                        case 'text-shadow-offset-y': if(l.type==='text') l.shadow.offsetY = input.value; break;
                        case 'asset-edge-enable': l.border.enabled = input.checked; document.getElementById('asset-edge-controls').classList.toggle('disabled', !input.checked); break;
                        case 'asset-edge-color': l.border.color = input.value; break;
                        case 'asset-edge-width': l.border.width = input.value; break;
                    }
                    if (!movieInteraction.active) drawFrame();
                });
            });
            const textMoveForwardBtn = document.getElementById('text-move-forward');
            const textMoveBackBtn = document.getElementById('text-move-back');
            if (textMoveForwardBtn) textMoveForwardBtn.addEventListener('click', () => { const l = getActiveLayer(); if (l?.type === 'text' && nudgeLayerZ(l.id, -1)) { renderLayerPalette(); renderTextLayerPalette(); updateTextOrderButtonsState(); drawFrame(); } });
            if (textMoveBackBtn) textMoveBackBtn.addEventListener('click', () => { const l = getActiveLayer(); if (l?.type === 'text' && nudgeLayerZ(l.id, +1)) { renderLayerPalette(); renderTextLayerPalette(); updateTextOrderButtonsState(); drawFrame(); } });
            const allSliders = document.querySelectorAll('#visuals-dropdown input[type=range], #text-dropdown input[type=range], #erase-tool-dropdown input[type=range], #mg-eraser-hud input[type=range]');
            const startScrubbing = (e) => {
                const slider = e.currentTarget;
                const container = slider.closest('.slider-container') || slider.closest('.row');
                const parentScrubTarget = slider.closest('[id$="-dropdown"]') || slider.closest('#mg-eraser-hud');
                if (slider.id === 'eraser-opacity' || slider.id === 'mg-eraser-strength-mini') { return; }
                if (parentScrubTarget && container) { parentScrubTarget.classList.add('is-scrubbing'); container.classList.add('is-active-slider'); }
            };
            const endScrubbing = () => { const scrubbedEl = document.querySelector('.is-scrubbing'); if (scrubbedEl) { const activeContainer = scrubbedEl.querySelector('.is-active-slider'); if (activeContainer) activeContainer.classList.remove('is-active-slider'); scrubbedEl.classList.remove('is-scrubbing'); } };
            allSliders.forEach(slider => { slider.addEventListener('mousedown', startScrubbing); slider.addEventListener('touchstart', startScrubbing, { passive: true }); });
            window.addEventListener('mouseup', endScrubbing);
            window.addEventListener('touchend', endScrubbing);
            window.addEventListener('click', (e) => {
                const popups = [ { dropdown: shortcutsDropdown, button: shortcutsBtn }, { dropdown: visualsDropdown, button: visualsBtn }, { dropdown: textDropdown, button: textBtn }, { dropdown: eraseToolDropdown, button: eraseToolBtn }, { dropdown: aiToolsDropdown, button: aiToolsBtn } ];
                const clickedOnEraserUI = eraseToolBtn.contains(e.target) || eraseToolDropdown.contains(e.target) || eraserHud.contains(e.target);
                if (eraserMode !== 'none' && !canvasPanel.contains(e.target) && !clickedOnEraserUI) { deactivateEraser(); }
                if (!customFontSelect.contains(e.target)) { closeFontDropdown(); }
                const aiModelSelect = document.getElementById('ai-model-select');
                if (aiModelSelect && !aiModelSelect.contains(e.target)) {
                    aiModelSelect.classList.remove('open');
                    aiModelSelect.querySelector('#ai-model-dropdown').classList.add('hidden');
                }
                popups.forEach(p => { if (!p.button.contains(e.target) && !p.dropdown.contains(e.target)) { if (p.dropdown.id === 'erase-tool-dropdown' && p.dropdown.classList.contains('visible') && eraserMode !== 'none' && !isEraserArmed) { isEraserArmed = true; showEraserHUD(true); updateEraserHudState(); movieCanvas.classList.add('erase-cursor'); const toastMsg = `${eraserMode==='erase'?'Erase':'Unerase'} Mode Activated. Click away from the layer to deactivate.`; toast(toastMsg, null); } p.dropdown.classList.remove('visible'); } });
            });
            viewAllLocalAssetsBtn.addEventListener('click', () => { renderFullLocalAssetFolder_IDB(); setLocalFolderTab('assets'); localAssetFolderOverlay.classList.add('visible'); });
            localAssetFolderCloseBtn.addEventListener('click', () => localAssetFolderOverlay.classList.remove('visible'));
            localAssetFolderOverlay.addEventListener('click', (e) => { if (e.target === localAssetFolderOverlay) localAssetFolderOverlay.classList.remove('visible'); });
            tabAssetsBtn.addEventListener('click', () => setLocalFolderTab('assets'));
            tabBackgroundsBtn.addEventListener('click', () => setLocalFolderTab('backgrounds'));
            eraserSizeMini.addEventListener('input', () => { eraserSizeSlider.value = eraserSizeMini.value; if (eraserZoomCanvas.classList.contains('visible') && lastEraseCanvasPoint) drawEraserZoomAt(lastEraseCanvasPoint); });
            eraserSizeSlider.addEventListener('input', () => { eraserSizeMini.value = eraserSizeMini.value; if (eraserZoomCanvas.classList.contains('visible') && lastEraseCanvasPoint) drawEraserZoomAt(lastEraseCanvasPoint); });
            eraserStrengthMini.addEventListener('input', () => eraserOpacitySlider.value = eraserStrengthMini.value);
            eraserOpacitySlider.addEventListener('input', () => eraserStrengthMini.value = eraserOpacitySlider.value);
            toggleViewBtn.addEventListener('click', toggleCanvasZoom);
            const canvasResizeObserver = new ResizeObserver(() => { resizeCanvas(); drawFrame(); });
            canvasResizeObserver.observe(canvasPanel);
        };
        
        async function initialize() {
            const loadingOverlay = document.getElementById('loading-overlay');
            const minDisplayTime = new Promise(resolve => setTimeout(resolve, 800)); 
            const setupPromise = (async () => {
                injectNonCriticalStyles();
                populateThemeList();
                populateBorderStylePopup();
                populateCustomFontSelector();
                await dedupeExistingAssetsByHashKeepNewest();
                updateControlsState();
                updateEditPanelsUI();
                setupEventListeners();
                drawFrame();
            })();
            await Promise.all([minDisplayTime, setupPromise]);
            loadingOverlay.style.opacity = '0';
            setTimeout(() => { loadingOverlay.style.display = 'none'; }, 500);
        }

        initialize();
    })();
</script>
</body>
</html>
